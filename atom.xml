<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小冉是不是该睡觉了</title>
  <subtitle>是时候理个发了吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-10-03T08:58:29.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BetterAA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>docker 使用小记</title>
    <link href="http://yoursite.com/2016/10/03/docker-%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/10/03/docker-使用小记/</id>
    <published>2016-10-03T03:29:36.000Z</published>
    <updated>2016-10-03T08:58:29.000Z</updated>
    
    <content type="html">&lt;p&gt;最近看师兄笔试安全工程师的题有很多考docker的，这两天来安装docker顺便来体验下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;依旧是简介：docker是什么&quot;&gt;&lt;a href=&quot;#依旧是简介：docker是什么&quot; class=&quot;headerlink&quot; title=&quot;依旧是简介：docker是什么&quot;&gt;&lt;/a&gt;依旧是简介：docker是什么&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;开源引擎&lt;/li&gt;
&lt;li&gt;可以轻松为任何为任何应用创建一个轻量级、可移植、自给自足的容器&lt;/li&gt;
&lt;li&gt;容器可以批量在生产环境中部署，包括 虚拟机、OpenStack集群&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;上手体验过程&quot;&gt;&lt;a href=&quot;#上手体验过程&quot; class=&quot;headerlink&quot; title=&quot;上手体验过程&quot;&gt;&lt;/a&gt;上手体验过程&lt;/h2&gt;&lt;h3 id=&quot;1-安装下载&quot;&gt;&lt;a href=&quot;#1-安装下载&quot; class=&quot;headerlink&quot; title=&quot;1. 安装下载&quot;&gt;&lt;/a&gt;1. 安装下载&lt;/h3&gt;&lt;p&gt;建议从官网下载安装包，这样能保证不会出现奇怪的问题&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.docker.com/mac/stable/Docker.dmg&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;mac版地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://download.docker.com/win/stable/InstallDocker.msi&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;windows版地址&lt;/a&gt;&lt;br&gt;我的百度云盘上存了备份&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.docker.com/engine/installation/linux/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;linux版的地址&lt;/a&gt; &lt;/p&gt;
&lt;p&gt;安装完毕之后 docker version 查看安装情况&lt;/p&gt;
&lt;h3 id=&quot;2-搜索可用的镜像&quot;&gt;&lt;a href=&quot;#2-搜索可用的镜像&quot; class=&quot;headerlink&quot; title=&quot;2. 搜索可用的镜像&quot;&gt;&lt;/a&gt;2. 搜索可用的镜像&lt;/h3&gt;&lt;p&gt;docker search xxx&lt;br&gt;这里以tutorial镜像为例&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker search tutorial&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;会找到不同用户空间下的名为tutorial的镜像，在docker的镜像索引网站上，镜像都是按照 用户名/镜像名 的方式来存储的。除了部分 像ubuntu这类基础镜像，经过官方验证，可信，可以直接用镜像名来检索到&lt;br&gt;（这里的用户指的是hub.docker.io官方的注册用户，建议同时也在docker官网上注册下，否则docker login时候会出问题）&lt;/p&gt;
&lt;h3 id=&quot;3-下载镜像&quot;&gt;&lt;a href=&quot;#3-下载镜像&quot; class=&quot;headerlink&quot; title=&quot;3. 下载镜像&quot;&gt;&lt;/a&gt;3. 下载镜像&lt;/h3&gt;&lt;p&gt;根据镜像的存储方式，用docker pull 即可。(和git类似)&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#下载learn用户下的tutorial镜像&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker pull learn/tutorial&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;4-在docker容器中运行hello-world&quot;&gt;&lt;a href=&quot;#4-在docker容器中运行hello-world&quot; class=&quot;headerlink&quot; title=&quot;4. 在docker容器中运行hello world&quot;&gt;&lt;/a&gt;4. 在docker容器中运行hello world&lt;/h3&gt;&lt;p&gt;docker run命令可以启动某个镜像，并运行一个命令&lt;br&gt;注： 【docker容器】可以理解为在沙盒中运行的【进程】，但是沙盒默认不会运行任何程序，你需要在沙盒中运行一个进程来启动某个容器。 这个进程是该容器的【唯一进程】&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#docker run &amp;lt;image name&amp;gt; &amp;lt;command&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run learn/tutorial &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;hello world&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;5-在容器中安装新的程序&quot;&gt;&lt;a href=&quot;#5-在容器中安装新的程序&quot; class=&quot;headerlink&quot; title=&quot;5. 在容器中安装新的程序&quot;&gt;&lt;/a&gt;5. 在容器中安装新的程序&lt;/h3&gt;&lt;p&gt;例子中要给之前pull的learn/tutorial镜像安装一个ping程序，因为tutorial是基于ubuntu的，因此可以通过apt-get来按照 &lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# -y参数避免进入交互模式，不需要确认&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker run learn/tutorial apt-get install -y ping&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;6-保存对容器的修改&quot;&gt;&lt;a href=&quot;#6-保存对容器的修改&quot; class=&quot;headerlink&quot; title=&quot;6. 保存对容器的修改&quot;&gt;&lt;/a&gt;6. 保存对容器的修改&lt;/h3&gt;&lt;p&gt;当对一个容器修改之后（例如上文docker run运行一个命令），可以把修改保存下来，下次从新版本上继续&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#获取按照完ping之后的容器id（只用到前几位区分即可），然后把这个镜像保存为betteraa/tutorial&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker ps &lt;span class=&quot;_&quot;&gt;-l&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker commit 84e betteraa/tutorial  &lt;span class=&quot;comment&quot;&gt;#利用上一步得到id&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;从此就有了一个新的镜像，名为betteraa/tutorial ，可以和上面一个docker run在里面运行新的命令&lt;/p&gt;
&lt;h3 id=&quot;7-查看运行中的镜像&quot;&gt;&lt;a href=&quot;#7-查看运行中的镜像&quot; class=&quot;headerlink&quot; title=&quot;7. 查看运行中的镜像&quot;&gt;&lt;/a&gt;7. 查看运行中的镜像&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker ps &lt;span class=&quot;comment&quot;&gt;#查看正在运行中的容器列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker inspect xxx &lt;span class=&quot;comment&quot;&gt;#查看更详细的关于一个容器的信息，xxx是id的前几位&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;8-发布修改后的镜像&quot;&gt;&lt;a href=&quot;#8-发布修改后的镜像&quot; class=&quot;headerlink&quot; title=&quot;8. 发布修改后的镜像&quot;&gt;&lt;/a&gt;8. 发布修改后的镜像&lt;/h3&gt;&lt;p&gt;步骤： 查看已有的镜像信息-》登录docker账号-》发布指定镜像&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker images &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker login  &lt;span class=&quot;comment&quot;&gt;#登录自己的docker，这里是betteraa&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker push betteraa/tutorial  &lt;span class=&quot;comment&quot;&gt;#只能发布到自己的名字空间中，所以这里是betteraa&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;————— 我是华丽的分割线 —————-&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上文是个简单的过程介绍，是先用一个已有的镜像，然后修改commit成一个新的镜像后发布，其实也可以自己制作镜像然后发布。&lt;/p&gt;
&lt;h3 id=&quot;下面介绍个简单的通过Dockerfile制作镜像的过程&quot;&gt;&lt;a href=&quot;#下面介绍个简单的通过Dockerfile制作镜像的过程&quot; class=&quot;headerlink&quot; title=&quot;下面介绍个简单的通过Dockerfile制作镜像的过程&quot;&gt;&lt;/a&gt;&lt;strong&gt;下面介绍个简单的通过Dockerfile制作镜像的过程&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;当你在使用 Docker构建镜像的时候，每一个命令都会在前一个命令的基础上形成一个新层&lt;/p&gt;
&lt;p&gt;通过Dockerfile自动构建容器的过程 其实就相当于上文把每个docker run的命令打包一起写到 一个Dockerfile文件中， 不过Dockerfile也有自己的一套简单的语法&lt;/p&gt;
&lt;p&gt;Docker语法包含两部分，注释# + 命令&lt;br&gt;这里先列举几个常用的，然后附上一个Dockerfile文件作为参考。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM ubuntu:14.10 使用哪个镜像作为基础镜像启动构建流程
MAINTAINER xxx 定义作者
RUN   用于【创建镜像】的命令，在之前commit层之上形成新的层
CMD   和run不同的是，这些命令不是在镜像构建过程中执行的，而是在镜像构建容器之后被调用
ENV  SERVER_WORK 4 设置环境变量，以key value形式定义
ADD命令有两个参数，源和目标。它的基本作用是从源系统的文件系统上复制文件到目标容器的文件系统。如果源是一个URL，那该URL的内容将被下载并复制到容器中。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;    &lt;/p&gt;
&lt;h3 id=&quot;示例：-创建一个Nginx的镜像&quot;&gt;&lt;a href=&quot;#示例：-创建一个Nginx的镜像&quot; class=&quot;headerlink&quot; title=&quot;示例： 创建一个Nginx的镜像&quot;&gt;&lt;/a&gt;&lt;strong&gt;示例： 创建一个Nginx的镜像&lt;/strong&gt;&lt;/h3&gt;&lt;h5 id=&quot;1-创建一个Dockerfile文件&quot;&gt;&lt;a href=&quot;#1-创建一个Dockerfile文件&quot; class=&quot;headerlink&quot; title=&quot;1.  创建一个Dockerfile文件&quot;&gt;&lt;/a&gt;1.  创建一个Dockerfile文件&lt;/h5&gt;&lt;pre&gt;&lt;code&gt;vim Dockerfile
&lt;/code&gt;&lt;/pre&gt;&lt;h5 id=&quot;2-编辑Dockerfile文件&quot;&gt;&lt;a href=&quot;#2-编辑Dockerfile文件&quot; class=&quot;headerlink&quot; title=&quot;2. 编辑Dockerfile文件&quot;&gt;&lt;/a&gt;2. 编辑Dockerfile文件&lt;/h5&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#Set the base image to Ubuntu&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;FROM ubuntu&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# File Author / Maintainer&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;MAINTAINER Example McAuthor&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;设置命令与参数下载Nginx&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install Nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Add application repository URL to the default sources&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;deb http://archive.ubuntu.com/ubuntu/ raring main 	universe&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/apt/sources.list&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Update the repository&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Install necessary tools&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get install -y nano wget dialog net-tools&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Download and Install Nginx&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN apt-get install -y nginx&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;安装nginx之后，需要配置Nginx并且替换掉其默认的配置文件&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Remove the default Nginx configuration file&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN rm -v /etc/nginx/nginx.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Copy a configuration file from the current directory&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ADD nginx.conf /etc/nginx/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Append &quot;daemon off;&quot; to the beginning of the configuration&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;RUN &lt;span class=&quot;built_in&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;daemon off;&quot;&lt;/span&gt; &amp;gt;&amp;gt; /etc/nginx/nginx.conf&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Expose ports&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EXPOSE 80&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Set the default command to execute&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# when creating a new container&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;CMD service nginx start&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;保存Dockerfile文件&lt;br&gt;这里ADD命令用到了一个nginx配置文件 ngnix.conf&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim ngnix.conf
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;具体配置如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;worker_processes 1;
events { worker_connections 1024; }
http {
     sendfile on;
         server {
         listen 80;
         location / {
              proxy_pass http://httpstat.us/;
              proxy_set_header X-Real-IP $remote_addr;
         }
     }
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;保存ngnix.conf&lt;/p&gt;
&lt;h5 id=&quot;3-开始构建镜像&quot;&gt;&lt;a href=&quot;#3-开始构建镜像&quot; class=&quot;headerlink&quot; title=&quot;3. 开始构建镜像&quot;&gt;&lt;/a&gt;3. 开始构建镜像&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build -t my_ngnix .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;—————— 又是华丽的分割线 —————-&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于docker镜像的清理与删除&quot;&gt;&lt;a href=&quot;#关于docker镜像的清理与删除&quot; class=&quot;headerlink&quot; title=&quot;关于docker镜像的清理与删除&quot;&gt;&lt;/a&gt;&lt;strong&gt;关于docker镜像的清理与删除&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;关于docker仓库的镜像的删除&lt;br&gt;其实感觉每个镜像都挺大的，因此清理下冗余的镜像也是有必要的&lt;/p&gt;
&lt;h5 id=&quot;1-停止所有的container，这样才能删除其中的images&quot;&gt;&lt;a href=&quot;#1-停止所有的container，这样才能删除其中的images&quot; class=&quot;headerlink&quot; title=&quot;1. 停止所有的container，这样才能删除其中的images&quot;&gt;&lt;/a&gt;1. 停止所有的container，这样才能删除其中的images&lt;/h5&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker stop $(docker ps -a -q)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h5 id=&quot;2-删除容器与删除镜像&quot;&gt;&lt;a href=&quot;#2-删除容器与删除镜像&quot; class=&quot;headerlink&quot; title=&quot;2. 删除容器与删除镜像&quot;&gt;&lt;/a&gt;2. 删除容器与删除镜像&lt;/h5&gt;&lt;p&gt;删除容器 docker rm +id&lt;br&gt;删除全部容器  docker rm $(docker ps -a -q)&lt;br&gt;删除镜像 docker rmi （image id)  #通过docker images获得镜像id&lt;/p&gt;
&lt;p&gt;删除全部镜像 docker rmi $(docker images -q)&lt;br&gt;（【docker容器】可以理解为在沙盒中运行的【进程】）&lt;br&gt;删除镜像有依赖关系的注意不能跨越子镜像，直接删除母镜像，需要按照入栈顺序来&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;br&gt;&lt;strong&gt;—————— 最后的分割线 ———————-&lt;/strong&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;
&lt;h3 id=&quot;docker的本地私有仓库搭建&quot;&gt;&lt;a href=&quot;#docker的本地私有仓库搭建&quot; class=&quot;headerlink&quot; title=&quot;docker的本地私有仓库搭建&quot;&gt;&lt;/a&gt;docker的本地私有仓库搭建&lt;/h3&gt;&lt;p&gt;和Maven一样， docker不仅提供了一个中央仓库（hub.docekr.io），同时也允许registry搭建本地私有仓库（就像本地git仓库）&lt;br&gt;好处：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节省带宽， 比中央仓库快很多。&lt;/li&gt;
&lt;li&gt;针对公司内部使用的镜像，可以供公司内部使用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;详细过程这里不展开谈了，需要的话可以参考这篇博文&lt;br&gt;&lt;a href=&quot;http://blog.csdn.net/wangtaoking1/article/details/44180901&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Docker学习笔记 — Docker私有仓库搭建&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大家国庆愉快~ 祖国母亲快乐 2016-10-3&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;p&gt;最近看师兄笔试安全工程师的题有很多考docker的，这两天来安装docker顺便来体验下。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Flask+uwsgi+ngix部署小记</title>
    <link href="http://yoursite.com/2016/07/23/Flask-uwsgi-ngix%E9%83%A8%E7%BD%B2%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2016/07/23/Flask-uwsgi-ngix部署小记/</id>
    <published>2016-07-23T03:24:32.000Z</published>
    <updated>2016-07-23T05:08:20.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;背景：-之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful-API，用python-index-py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下&quot;&gt;&lt;a href=&quot;#背景：-之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful-API，用python-index-py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下&quot; class=&quot;headerlink&quot; title=&quot;背景： 之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful API，用python index.py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下~&quot;&gt;&lt;/a&gt;背景： 之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful API，用python index.py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下~&lt;/h4&gt;&lt;h3 id=&quot;工具：&quot;&gt;&lt;a href=&quot;#工具：&quot; class=&quot;headerlink&quot; title=&quot;工具：&quot;&gt;&lt;/a&gt;工具：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Flask：一个使用 Python 编写的轻量级 Web 应用框架 &lt;/li&gt;
&lt;li&gt;uwsgi：是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议&lt;/li&gt;
&lt;li&gt;nginx：一个高性能的HTTP和 反向代理 服务器，也是一个 IMAP/POP3/SMTP（电子邮件）服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;正式步骤：&quot;&gt;&lt;a href=&quot;#正式步骤：&quot; class=&quot;headerlink&quot; title=&quot;正式步骤：&quot;&gt;&lt;/a&gt;正式步骤：&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;首先，默认上面的三个组件你是安装好的&lt;/p&gt;
&lt;h4 id=&quot;1-创建Flask工程（如果已有的话可以直接到2）&quot;&gt;&lt;a href=&quot;#1-创建Flask工程（如果已有的话可以直接到2）&quot; class=&quot;headerlink&quot; title=&quot;1. 创建Flask工程（如果已有的话可以直接到2）&quot;&gt;&lt;/a&gt;1. 创建Flask工程（如果已有的话可以直接到2）&lt;/h4&gt;&lt;p&gt;这里还是用Helloworld吧~&lt;br&gt;创建一个工程目录helloworld，里面包含主文件index.py&lt;/p&gt;
&lt;p&gt;简单示例代码&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; flask &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Flask&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;app = Flask(__name__)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@app.route(&#39;/&#39;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;Hello World&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; __name__ == &lt;span class=&quot;string&quot;&gt;&#39;__main__&#39;&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    app.run()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;2-配置uwsgi&quot;&gt;&lt;a href=&quot;#2-配置uwsgi&quot; class=&quot;headerlink&quot; title=&quot;2.配置uwsgi&quot;&gt;&lt;/a&gt;2.配置uwsgi&lt;/h4&gt;&lt;p&gt;在上面工程目录Helloworld里面新建一个uwsgi的xml配置文件flasksite.xml&lt;br&gt;示例配置：&lt;/p&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;uwsgi&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	#这个是上一步新建的工程文件夹，在helloworld里pwd可以看到&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;pythonpath&lt;/span&gt;&amp;gt;&lt;/span&gt;/home/ubuntu/helloworld&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;pythonpath&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     #这是上一步新建的python文件，模块名即index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;module&lt;/span&gt;&amp;gt;&lt;/span&gt;index&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;module&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     #这是启动服务器的入口，就是index.py里面app.run()的app&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;callable&lt;/span&gt;&amp;gt;&lt;/span&gt;app&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;callable&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     #配置套接字，与下文的nginx配置一致，用于内部交互&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;socket&lt;/span&gt;&amp;gt;&lt;/span&gt;127.0.0.1:8000&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;socket&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;master&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     #跑几个线程&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;processes&lt;/span&gt;&amp;gt;&lt;/span&gt;4&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;processes&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;memory-report&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;uwsgi&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其实除了xml文件配置，也可以通过命令行参数方法启动uwsgi时配置，例如&lt;br&gt;sudo uwsgi -s 127.0.0.1：8000 –module index –callable app –process 4&lt;/p&gt;
&lt;h4 id=&quot;3-配置nginx&quot;&gt;&lt;a href=&quot;#3-配置nginx&quot; class=&quot;headerlink&quot; title=&quot;3.配置nginx&quot;&gt;&lt;/a&gt;3.配置nginx&lt;/h4&gt;&lt;p&gt;在/etc/nginx/sites-available目录下，创建站点配置文件helloWorldSite:&lt;br&gt;示例配置如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;server {
listen 5000;   #这个是对外转发监听的端口，就是外网访问123.206.23.xx：5000可以响应
server_name localhost;
location / {
#这还是项目的根目录路径
root /home/ubuntu/helloworld;
include uwsgi_params;
#这是对内和uwsgi交互的端口，需要和上面uwsgi的端口一致
uwsgi_pass 127.0.0.1:8000;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   }&lt;br&gt;}&lt;/p&gt;
&lt;p&gt;然后用ln命令创建一个link从上面sites-available/helloWorldSite到/etc/nginx/sites-enable/里，link的名字叫helloWorldSite，同时删除sites-enable目录下的default的link（注意之前自己也配置过的不知道要不要删除，可以试一下）:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo ln -s /etc/nginx/sites-available/helloWorldSite /etc/nginx/sites-enabled/     
sudo rm /etc/nginx/sites-enabled/default #去除默认站点配置
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;4-开始部署&quot;&gt;&lt;a href=&quot;#4-开始部署&quot; class=&quot;headerlink&quot; title=&quot;4.开始部署&quot;&gt;&lt;/a&gt;4.开始部署&lt;/h4&gt;&lt;p&gt;1）. 启动uwsgi（使用上面配置的uwsgi配置文件）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo uwsgi -x /home/ubuntu/helloworld/flasksite.xml
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;上面提到过，或者也可以不同xml，直接在命令行里配置参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo uwsgi -s 127.0.0.1:8000 --module index --callable app --process 4
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;2）. 新开一个Terminal，在里面启动nginx&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo /etc/init.d/nginx start
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sudo service nginx start
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;5-完成，测试&quot;&gt;&lt;a href=&quot;#5-完成，测试&quot; class=&quot;headerlink&quot; title=&quot;5. 完成，测试&quot;&gt;&lt;/a&gt;5. 完成，测试&lt;/h4&gt;&lt;p&gt;如果是给本地机器配的话，就直接访问localhost:5000 即可 #因为上面nginx的listen里面是5000&lt;/p&gt;
&lt;p&gt;如果是给服务器配置的的话，就访问服务器的ip：5000即可，完成！&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;背景：-之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful-API，用python-index-py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下&quot;&gt;&lt;a href=&quot;#背景：-之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful-API，用python-index-py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下&quot; class=&quot;headerlink&quot; title=&quot;背景： 之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful API，用python index.py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下~&quot;&gt;&lt;/a&gt;背景： 之前在腾讯云的服务器上面用Flask写了一些小东东作为后台，温习了一下RESTful API，用python index.py就可以跑起来，但是过一段时间自己会停掉，当然还有很多其他问题，于是准备试试如何正式部署到wsgi服务器环境，亲测可用，小记一下~&lt;/h4&gt;&lt;h3 id=&quot;工具：&quot;&gt;&lt;a href=&quot;#工具：&quot; class=&quot;headerlink&quot; title=&quot;工具：&quot;&gt;&lt;/a&gt;工具：&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Flask：一个使用 Python 编写的轻量级 Web 应用框架 &lt;/li&gt;
&lt;li&gt;uwsgi：是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议&lt;/li&gt;
&lt;li&gt;nginx：一个高性能的HTTP和 反向代理 服务器，也是一个 IMAP/POP3/SMTP（电子邮件）服务器&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;正式步骤：&quot;&gt;&lt;a href=&quot;#正式步骤：&quot; class=&quot;headerlink&quot; title=&quot;正式步骤：&quot;&gt;&lt;/a&gt;正式步骤：&lt;/h3&gt;
    
    </summary>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
      <category term="ngix" scheme="http://yoursite.com/tags/ngix/"/>
    
  </entry>
  
  <entry>
    <title>《python网络数据采集》学习笔记-NLTK</title>
    <link href="http://yoursite.com/2016/07/19/%E3%80%8Apython%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-NLTK/"/>
    <id>http://yoursite.com/2016/07/19/《python网络数据采集》学习笔记-NLTK/</id>
    <published>2016-07-19T09:23:59.000Z</published>
    <updated>2016-07-19T09:38:51.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;《python网络数据采集》-一书中自然语言处理基础学习&quot;&gt;&lt;a href=&quot;#《python网络数据采集》-一书中自然语言处理基础学习&quot; class=&quot;headerlink&quot; title=&quot;《python网络数据采集》 一书中自然语言处理基础学习&quot;&gt;&lt;/a&gt;《python网络数据采集》 一书中自然语言处理基础学习&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# from nltk import word_tokenize
from nltk import Text
#用NLTK做统计分析一般都是从Text对象开始的
tokens = word_tokenize(&amp;quot;here is some not very interesting text is&amp;quot;)
text = Text(tokens)
#Text对象的长度就是 单词的个数
print len(text)
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;from nltk import FreqDist #计算词频
from nltk.book import text6 #用的是自带的基本书，一共有10本，这里用第6本
fdist = FreqDist(text6)
fdist.most_common(5)  #直接找出按照词频排前10的单词
fdist[&amp;quot;Grail&amp;quot;]        #也可以直接找出某个词的词频
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h3 id=&quot;-1&quot;&gt;&lt;a href=&quot;#-1&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#直接调用n-gram模型
from nltk import ngrams
fourgrams = ngrams(text6,4)
#词频类也可以对n-gram词典进行统计词频
fourgramsDist = FreqDist(fourgrams)
#直接查找这个4序列的频率
fourgramsDist[(&amp;quot;father&amp;quot;,&amp;quot;smelt&amp;quot;,&amp;quot;of&amp;quot;,&amp;quot;elderberries&amp;quot;)] #输出1，表示出现了一次
for fourgram in fourgrams:
if fourgram[0] == &amp;quot;cocount&amp;quot;: #直接判断4-gram列表里面的第一个词是cocount的
    print(fourgram)    
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h3 id=&quot;-2&quot;&gt;&lt;a href=&quot;#-2&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#词性分析
from nltk import pos_tag
text = word_tokenize(&amp;quot;The dust was thick so he has to dust&amp;quot;)
pos_tag(text)  #是一个列表[] ,列表里面的每一个都是一个tuple二元组
#DT，NN等都是词性标记的缩写，在《python网络数据采集》一书的P116
#这里dust出现了两次，词性不同，识别方式是通过形式语言的“上下文无关文法”，形式语言的上下文无关文法确定的是一个词性后面可以跟哪些词性

//OUT
[(&amp;apos;The&amp;apos;, &amp;apos;DT&amp;apos;),
(&amp;apos;dust&amp;apos;, &amp;apos;NN&amp;apos;),
(&amp;apos;was&amp;apos;, &amp;apos;VBD&amp;apos;),    
(&amp;apos;thick&amp;apos;, &amp;apos;RB&amp;apos;),
(&amp;apos;so&amp;apos;, &amp;apos;RB&amp;apos;), 
(&amp;apos;he&amp;apos;, &amp;apos;PRP&amp;apos;),
(&amp;apos;has&amp;apos;, &amp;apos;VBZ&amp;apos;),
(&amp;apos;to&amp;apos;, &amp;apos;TO&amp;apos;),
(&amp;apos;dust&amp;apos;, &amp;apos;VB&amp;apos;)]
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h2 id=&quot;-3&quot;&gt;&lt;a href=&quot;#-3&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#对于词性的应用，找出一段文字中作为名词而不是动词的“google”
from nltk import sent_tokenize
#sent_tokenize 用来将一段话分解成句子， 而word_tokenize是将一句话分词
sentences = sent_tokenize(&amp;quot;Google is one of the best companies in the world. I constantly google myself to see what i&amp;apos;m to.&amp;quot;)
nouns = [&amp;apos;NN&amp;apos;,&amp;apos;NNS&amp;apos;,&amp;apos;NNP&amp;apos;,&amp;apos;NNPS&amp;apos;] #将词性标注中属于名词的列出来，统计为名词
for sentence in sentences:
    if &amp;apos;google&amp;apos; in sentence.lower(): #判断句子中有没有google一词
        taggedWords = pos_tag(word_tokenize(sentence)) #
        for word in taggedWords: #每个是二元组
            if word[0].lower() == &amp;quot;google&amp;quot; and word[1] in nouns:
                print(sentence) #打印出包含名词google的句子

#OUT
Google is one of the best companies in the world.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自然语言中的许多-歧义问题-都可以用-pos-tag-解决，不只是搜索-目标单词或短语，而是搜索【带标记的目标单词和短语】&quot;&gt;&lt;a href=&quot;#自然语言中的许多-歧义问题-都可以用-pos-tag-解决，不只是搜索-目标单词或短语，而是搜索【带标记的目标单词和短语】&quot; class=&quot;headerlink&quot; title=&quot;自然语言中的许多  歧义问题  都可以用 pos_tag 解决，不只是搜索 目标单词或短语，而是搜索【带标记的目标单词和短语】&quot;&gt;&lt;/a&gt;自然语言中的许多  歧义问题  都可以用 pos_tag 解决，不只是搜索 目标单词或短语，而是搜索【带标记的目标单词和短语】&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;《python网络数据采集》-一书中自然语言处理基础学习&quot;&gt;&lt;a href=&quot;#《python网络数据采集》-一书中自然语言处理基础学习&quot; class=&quot;headerlink&quot; title=&quot;《python网络数据采集》 一书中自然语言处理基础学习&quot;&gt;&lt;/a&gt;《python网络数据采集》 一书中自然语言处理基础学习&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# from nltk import word_tokenize
from nltk import Text
#用NLTK做统计分析一般都是从Text对象开始的
tokens = word_tokenize(&amp;quot;here is some not very interesting text is&amp;quot;)
text = Text(tokens)
#Text对象的长度就是 单词的个数
print len(text)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="NLTK" scheme="http://yoursite.com/tags/NLTK/"/>
    
  </entry>
  
  <entry>
    <title>JAVA hashMap and treeMap</title>
    <link href="http://yoursite.com/2016/07/19/JAVA-hashMap-and-treeMap/"/>
    <id>http://yoursite.com/2016/07/19/JAVA-hashMap-and-treeMap/</id>
    <published>2016-07-19T08:28:16.000Z</published>
    <updated>2016-07-19T08:46:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;这里简单介绍下这两个map&quot;&gt;&lt;a href=&quot;#这里简单介绍下这两个map&quot; class=&quot;headerlink&quot; title=&quot;这里简单介绍下这两个map&quot;&gt;&lt;/a&gt;这里简单介绍下这两个map&lt;/h2&gt;&lt;p&gt;也是一些我从网上收集的内容，有些测过有些没测，可能有不对的地方 ：D&lt;/p&gt;
&lt;h3 id=&quot;关于hashMap和-treeMap&quot;&gt;&lt;a href=&quot;#关于hashMap和-treeMap&quot; class=&quot;headerlink&quot; title=&quot;关于hashMap和 treeMap&quot;&gt;&lt;/a&gt;关于hashMap和 treeMap&lt;/h3&gt;&lt;p&gt;HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序（内部实现应该是红黑树），如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。&lt;/p&gt;
&lt;h3 id=&quot;性能对比：&quot;&gt;&lt;a href=&quot;#性能对比：&quot; class=&quot;headerlink&quot; title=&quot;性能对比：&quot;&gt;&lt;/a&gt;性能对比：&lt;/h3&gt;&lt;p&gt;两种常规Map性能&lt;br&gt;HashMap：适用于在Map中插入、删除和定位元素。&lt;br&gt;Treemap：适用于按自然顺序或自定义顺序遍历键(key)。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。&lt;/p&gt;
&lt;h3 id=&quot;用法：&quot;&gt;&lt;a href=&quot;#用法：&quot; class=&quot;headerlink&quot; title=&quot;用法：&quot;&gt;&lt;/a&gt;用法：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Hashtable&amp;lt;String, String&amp;gt; map = new Hashtable&amp;lt;String, String&amp;gt;();
map.put(&amp;quot;a&amp;quot;, &amp;quot;aaa&amp;quot;);
//遍历写法（推荐下面的写法，效率高些）
//遍历key
for (String key : map.keySet()) {
    value = map.get(key);
}
//遍历整个键值对 :一个entry
for (Entry&amp;lt;String, String&amp;gt; entry: map.entrySet()) {
    key = entry.getKey();
    value = entry.getValue();
}
//遍历value
for (String value : map.values()) {

}
//判断是否存在key
map. containsKey(test)
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这里简单介绍下这两个map&quot;&gt;&lt;a href=&quot;#这里简单介绍下这两个map&quot; class=&quot;headerlink&quot; title=&quot;这里简单介绍下这两个map&quot;&gt;&lt;/a&gt;这里简单介绍下这两个map&lt;/h2&gt;&lt;p&gt;也是一些我从网上收集的内容，有些测过有些没测，可能有不对的地方 ：D&lt;/p&gt;
&lt;h3 id=&quot;关于hashMap和-treeMap&quot;&gt;&lt;a href=&quot;#关于hashMap和-treeMap&quot; class=&quot;headerlink&quot; title=&quot;关于hashMap和 treeMap&quot;&gt;&lt;/a&gt;关于hashMap和 treeMap&lt;/h3&gt;&lt;p&gt;HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序（内部实现应该是红黑树），如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。&lt;/p&gt;
&lt;h3 id=&quot;性能对比：&quot;&gt;&lt;a href=&quot;#性能对比：&quot; class=&quot;headerlink&quot; title=&quot;性能对比：&quot;&gt;&lt;/a&gt;性能对比：&lt;/h3&gt;&lt;p&gt;两种常规Map性能&lt;br&gt;HashMap：适用于在Map中插入、删除和定位元素。&lt;br&gt;Treemap：适用于按自然顺序或自定义顺序遍历键(key)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>python+BeautifulSoup 爬虫 正则 简单示例</title>
    <link href="http://yoursite.com/2016/07/16/python-BeautifulSoup-%E7%88%AC%E8%99%AB-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2016/07/16/python-BeautifulSoup-爬虫-简单示例/</id>
    <published>2016-07-16T13:52:52.000Z</published>
    <updated>2016-07-16T14:01:01.000Z</updated>
    
    <content type="html">&lt;p&gt;##这里是直接用源码+重要注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-*- coding:utf-8 -*-
from urllib import urlopen
from bs4 import BeautifulSoup
import requests
import re
import time

url = &amp;quot;&amp;quot;
domain = &amp;quot;&amp;quot;

sessions = requests.Session()
#注意; 这里没有对编码处理，输出中文字符乱码。。decode（“utf-8”）
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;#还有别的header也可以加
header = {&amp;quot;User-Agent&amp;quot;:&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/600.7.12 (KHTML, like Gecko) Version/8.0.7 Safari/600.7.12&amp;quot;}
req = sessions.get(url,headers=header)

bsObj = BeautifulSoup(req.text)
#可以直接找tbody，省的再先找table，但是这样没有那样稳妥
#findAll和find函数都是的第一个都是标签的类型，如p，div，后面的{}是属性集合
#第一个标签类型也可以不填，那就都找
table_tbody = bsObj.find(&amp;quot;tbody&amp;quot;,{&amp;quot;style&amp;quot;:&amp;quot;table-layout:fixed;&amp;quot;})
trs = table_tbody.findAll(&amp;quot;tr&amp;quot;,{&amp;quot;class&amp;quot;:&amp;quot;tr3 t_one&amp;quot;})

subURLs = []
for tr in trs:
_url = tr.find(&amp;quot;a&amp;quot;,{&amp;quot;target&amp;quot;:&amp;quot;_blank&amp;quot;}).attrs[&amp;quot;href”]  #找到标签后用attrs可以找到属性
subURLs.append(domain+_url)

#print &amp;apos;\n&amp;apos;.join(subURLs)
#边爬数据边写，避免中途异常后无数据
out = open(&amp;quot;./out&amp;quot;,&amp;quot;w&amp;quot;)

real_url = []
for _url in subURLs:
#记得异常处理
try:
    #这里避免请求太频繁，因此每次暂停2秒
    time.sleep(2)
    print &amp;apos;In url: &amp;apos;+_url
    _req = sessions.get(_url,headers= header)
    _bsObj = BeautifulSoup(_req.text)
    _a = _bsObj.find(&amp;quot;div&amp;quot;,{&amp;quot;class&amp;quot;:&amp;quot;tpc_content do_not_catch&amp;quot;}).find(&amp;quot;a&amp;quot;,{&amp;quot;style&amp;quot;:&amp;quot;cursor:pointer&amp;quot;})
#_a.get_text() 可以得到a标签的文本
#（.*?）是正则里面的东西，可以匹配全部的内容，前面\’是’转义，此处我们的待匹配字符串是.src=.....’” style..
#我们要取到的是src后面...
    #real_url.append(re.findall(r&amp;apos;.src=\&amp;apos;(.*?)\&amp;apos;\&amp;quot; style&amp;apos;,str(_a))[0])  #转成字符串str处理
    out.write(re.findall(r&amp;apos;.src=\&amp;apos;(.*?)\&amp;apos;\&amp;quot; style&amp;apos;,str(_a))[0]+&amp;apos;\n&amp;apos;)
except:
    print &amp;apos;爬取失败&amp;apos;
finally:
    out.close()

out.close()
#out.write(&amp;apos;\n&amp;apos;.join(real_url))
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;##这里是直接用源码+重要注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-*- coding:utf-8 -*-
from urllib import urlopen
from bs4 import BeautifulSoup
import requests
import re
import time

url = &amp;quot;&amp;quot;
domain = &amp;quot;&amp;quot;

sessions = requests.Session()
#注意; 这里没有对编码处理，输出中文字符乱码。。decode（“utf-8”）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JAVA异常：Comparison method violates its general contract</title>
    <link href="http://yoursite.com/2016/07/05/JAVA%E5%BC%82%E5%B8%B8%EF%BC%9AComparison-method-violates-its-general-contract/"/>
    <id>http://yoursite.com/2016/07/05/JAVA异常：Comparison-method-violates-its-general-contract/</id>
    <published>2016-07-05T04:00:10.000Z</published>
    <updated>2016-07-05T04:23:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;异常描述&quot;&gt;&lt;a href=&quot;#异常描述&quot; class=&quot;headerlink&quot; title=&quot;异常描述&quot;&gt;&lt;/a&gt;异常描述&lt;/h2&gt;&lt;p&gt;java.lang.IllegalArgumentException: Comparison method violates its general contract!&lt;/p&gt;
&lt;h2 id=&quot;异常举例&quot;&gt;&lt;a href=&quot;#异常举例&quot; class=&quot;headerlink&quot; title=&quot;异常举例&quot;&gt;&lt;/a&gt;异常举例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
    public int compare(Integer o1, Integer o2) {  
        return o1 &amp;gt; o2 ? 1 : -1;// 错误的方式  
    }  
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;异常原因&quot;&gt;&lt;a href=&quot;#异常原因&quot; class=&quot;headerlink&quot; title=&quot;异常原因&quot;&gt;&lt;/a&gt;异常原因&lt;/h2&gt;&lt;p&gt;JDK7的sort函数实现变了，与旧版本的不同，存在兼容问题，可以查看下自己的compare函数实现有木有问题&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;新版本中对比较有约束条件，如果违反了约束条件就会抛出llegalArgumentException异常，JDK6中则忽略了这种情况，那么新的约束是啥子？&lt;br&gt;&lt;img src=&quot;compare.png&quot; alt=&quot;compare&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sgn(compare(x, y)) == -sgn(compare(y, x))&lt;/li&gt;
&lt;li&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0)) implies compare(x, z)&amp;gt;0&lt;/li&gt;
&lt;li&gt;compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，上面的异常举例就有问题了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return x &amp;gt; y ? 1 : -1; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当x == y时，sgn(compare(x, y))  = -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;JVM启动参数 增加 -Djava.util.Arrays.useLegacyMergeSort=true&lt;/li&gt;
&lt;li&gt;改动compare函数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
public int compare(Integer o1, Integer o2) {  
// return o1 &amp;gt; o2 ? 1 : -1;  
return o1.compareTo(o2);// 正确的方式 
//或者 return  o1 &amp;gt;= o2 ? 1 : -1; 
}  
}); 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常描述&quot;&gt;&lt;a href=&quot;#异常描述&quot; class=&quot;headerlink&quot; title=&quot;异常描述&quot;&gt;&lt;/a&gt;异常描述&lt;/h2&gt;&lt;p&gt;java.lang.IllegalArgumentException: Comparison method violates its general contract!&lt;/p&gt;
&lt;h2 id=&quot;异常举例&quot;&gt;&lt;a href=&quot;#异常举例&quot; class=&quot;headerlink&quot; title=&quot;异常举例&quot;&gt;&lt;/a&gt;异常举例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
    public int compare(Integer o1, Integer o2) {  
        return o1 &amp;gt; o2 ? 1 : -1;// 错误的方式  
    }  
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;异常原因&quot;&gt;&lt;a href=&quot;#异常原因&quot; class=&quot;headerlink&quot; title=&quot;异常原因&quot;&gt;&lt;/a&gt;异常原因&lt;/h2&gt;&lt;p&gt;JDK7的sort函数实现变了，与旧版本的不同，存在兼容问题，可以查看下自己的compare函数实现有木有问题&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop hive 分区partition</title>
    <link href="http://yoursite.com/2016/06/15/Hadoop-hive-%E5%88%86%E5%8C%BApartition/"/>
    <id>http://yoursite.com/2016/06/15/Hadoop-hive-分区partition/</id>
    <published>2016-06-15T07:23:34.000Z</published>
    <updated>2016-06-15T08:09:42.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Hive是啥子？&quot;&gt;&lt;a href=&quot;#Hive是啥子？&quot; class=&quot;headerlink&quot; title=&quot;Hive是啥子？&quot;&gt;&lt;/a&gt;Hive是啥子？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。（将输入的hql语句解析成待提交的job）&lt;/li&gt;
&lt;li&gt;本质是将SQL转换为MapReduce程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Hive-特点&quot;&gt;&lt;a href=&quot;#Hive-特点&quot; class=&quot;headerlink&quot; title=&quot;Hive 特点&quot;&gt;&lt;/a&gt;Hive 特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可扩展： 可自由扩展集群规模，一般无需重启服务&lt;/li&gt;
&lt;li&gt;延展性： 支持自定义函数&lt;/li&gt;
&lt;li&gt;容错性： 良好的容错性，节点出现问题SQL仍可完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;hive与Hadoop的关系&quot;&gt;&lt;a href=&quot;#hive与Hadoop的关系&quot; class=&quot;headerlink&quot; title=&quot;hive与Hadoop的关系&quot;&gt;&lt;/a&gt;hive与Hadoop的关系&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;hadoop-hive.jpg&quot; alt=&quot;hive与hadoop的关系&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于分区partition的概念&quot;&gt;&lt;a href=&quot;#关于分区partition的概念&quot; class=&quot;headerlink&quot; title=&quot;关于分区partition的概念&quot;&gt;&lt;/a&gt;关于分区partition的概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在Hive Select语句查询中一般会扫描整个表内容，会消耗很多时间做没必要的工作。有时候只需要扫描表中关心的一部分数据，因此建表时引入了partition概念&lt;/li&gt;
&lt;li&gt;分区表指的是在创建表时指定的partition的分区空间&lt;/li&gt;
&lt;li&gt;如果需要创建有分区的表，需要在create表的时候调用可选参数partitioned by，&lt;/li&gt;
&lt;li&gt;一个表可以拥有一个或者多个分区，每个分区以文件夹的形式单独存在表文件夹的目录下。&lt;/li&gt;
&lt;li&gt;分区是以字段的形式在表结构中存在，通过describe table命令可以查看到字段存在，但是该字段不存放实际的数据内容，仅仅是分区的表示。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;分区建立&quot;&gt;&lt;a href=&quot;#分区建立&quot; class=&quot;headerlink&quot; title=&quot;分区建立&quot;&gt;&lt;/a&gt;分区建立&lt;/h4&gt;&lt;p&gt; 分区建表分为2种，一种是单分区，也就是说在表文件夹目录下只有一级文件夹目录。另外一种是多分区，表文件夹下出现多文件夹嵌套模式。&lt;/p&gt;
&lt;p&gt;  a. 单分区建表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table day_table (id int, content string) partitioned by (dt string);单分区表，按天分区，在表结构中存在id，content，dt三列。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  b. 双分区建表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table day_hour_table (id int, content string) partitioned by (dt string, hour string);双分区表，按天和小时分区，在表结构中新增加了dt和hour两列。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;添加分区&quot;&gt;&lt;a href=&quot;#添加分区&quot; class=&quot;headerlink&quot; title=&quot;添加分区&quot;&gt;&lt;/a&gt;添加分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ALTER TABLE day_table ADD PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;08&amp;apos;) location &amp;apos;/path/pv1.txt&amp;apos; PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;09&amp;apos;) location &amp;apos;/path/pv2.txt&amp;apos;;    
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除分区&quot;&gt;&lt;a href=&quot;#删除分区&quot; class=&quot;headerlink&quot; title=&quot;删除分区&quot;&gt;&lt;/a&gt;删除分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ALTER TABLE day_hour_table DROP PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;09&amp;apos;);    
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;数据加载进分区&quot;&gt;&lt;a href=&quot;#数据加载进分区&quot; class=&quot;headerlink&quot; title=&quot;数据加载进分区&quot;&gt;&lt;/a&gt;数据加载进分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;LOAD DATA INPATH &amp;apos;/user/pv.txt&amp;apos; INTO TABLE day_hour_table PARTITION(dt=&amp;apos;2008-08- 08&amp;apos;, hour=&amp;apos;08&amp;apos;);

LOAD DATA local INPATH &amp;apos;/user/hua/*&amp;apos; INTO TABLE day_hour partition(dt=&amp;apos;2010-07- 07&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   当数据被加载至表中时，不会对数据进行任何转换。Load操作只是将数据复制至Hive表对应的位置。数据加载时在表下自动创建一个目录，文件存放在该分区下。&lt;/p&gt;
&lt;h4 id=&quot;基于分区的查询语句&quot;&gt;&lt;a href=&quot;#基于分区的查询语句&quot; class=&quot;headerlink&quot; title=&quot;基于分区的查询语句&quot;&gt;&lt;/a&gt;基于分区的查询语句&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;SELECT day_table.* FROM day_table WHERE day_table.dt&amp;gt;= &amp;apos;2008-08-08&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;查看表的分区&quot;&gt;&lt;a href=&quot;#查看表的分区&quot; class=&quot;headerlink&quot; title=&quot;查看表的分区&quot;&gt;&lt;/a&gt;查看表的分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;hive&amp;gt; 
show partitions day_hour_table; 

OK 
dt=2008-08-08/hour=08 
dt=2008-08-08/hour=09 
dt=2008-08-09/hour=09;
...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;总的说来partition就是辅助查询，缩小查询范围，加快数据的检索速度和对数据按照一定的规格和条件进行管理。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hive是啥子？&quot;&gt;&lt;a href=&quot;#Hive是啥子？&quot; class=&quot;headerlink&quot; title=&quot;Hive是啥子？&quot;&gt;&lt;/a&gt;Hive是啥子？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。（将输入的hql语句解析成待提交的job）&lt;/li&gt;
&lt;li&gt;本质是将SQL转换为MapReduce程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Hive-特点&quot;&gt;&lt;a href=&quot;#Hive-特点&quot; class=&quot;headerlink&quot; title=&quot;Hive 特点&quot;&gt;&lt;/a&gt;Hive 特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可扩展： 可自由扩展集群规模，一般无需重启服务&lt;/li&gt;
&lt;li&gt;延展性： 支持自定义函数&lt;/li&gt;
&lt;li&gt;容错性： 良好的容错性，节点出现问题SQL仍可完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;hive与Hadoop的关系&quot;&gt;&lt;a href=&quot;#hive与Hadoop的关系&quot; class=&quot;headerlink&quot; title=&quot;hive与Hadoop的关系&quot;&gt;&lt;/a&gt;hive与Hadoop的关系&lt;/h3&gt;
    
    </summary>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>c++ snippets</title>
    <link href="http://yoursite.com/2016/05/10/c-snippets/"/>
    <id>http://yoursite.com/2016/05/10/c-snippets/</id>
    <published>2016-05-10T14:50:52.000Z</published>
    <updated>2016-05-10T16:23:15.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot;&gt;&lt;a href=&quot;#Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot; class=&quot;headerlink&quot; title=&quot;Note: 带符号的整数n，进行-1乘n操作时，小心n=-2147483648，这时-1*n会溢出，可以 n++-1；&quot;&gt;&lt;/a&gt;Note: 带符号的整数n，进行-1乘n操作时，小心n=-2147483648，这时-1*n会溢出，可以 n++-1；&lt;/h4&gt;&lt;h4 id=&quot;1-c-str-：生成一个const-char-指针，指向以空字符终止的数组。&quot;&gt;&lt;a href=&quot;#1-c-str-：生成一个const-char-指针，指向以空字符终止的数组。&quot; class=&quot;headerlink&quot; title=&quot;1. c_str()：生成一个const char*指针，指向以空字符终止的数组。&quot;&gt;&lt;/a&gt;1. c_str()：生成一个const char*指针，指向以空字符终止的数组。&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;char* c=new char[20];
string s=&amp;quot;1234&amp;quot;;
//c = s.c_str(); 
strcpy(c,s.c_str());
cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl; //输出：1234
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-将字符串转换为数字&quot;&gt;&lt;a href=&quot;#2-将字符串转换为数字&quot; class=&quot;headerlink&quot; title=&quot;2.将字符串转换为数字&quot;&gt;&lt;/a&gt;2.将字符串转换为数字&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;string source = &amp;quot;123&amp;quot;;
atoi(source.c_str());
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot;&gt;&lt;a href=&quot;#Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot; class=&quot;h
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="snippet" scheme="http://yoursite.com/tags/snippet/"/>
    
  </entry>
  
  <entry>
    <title>c++ vector容器常用操作</title>
    <link href="http://yoursite.com/2016/05/09/c-vector%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/05/09/c-vector容器常用操作/</id>
    <published>2016-05-08T16:20:46.000Z</published>
    <updated>2016-05-08T17:03:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;a href=&quot;#其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot; class=&quot;headerlink&quot; title=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;/a&gt;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&lt;/h2&gt;&lt;h4 id=&quot;Note：&quot;&gt;&lt;a href=&quot;#Note：&quot; class=&quot;headerlink&quot; title=&quot;Note：&quot;&gt;&lt;/a&gt;Note：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量使用reserve来减少不必要的内存分配次数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原则：尽量使用empty()而不是size()==0 来判断容器是否为空&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;0x00-vector-的初始化&quot;&gt;&lt;a href=&quot;#0x00-vector-的初始化&quot; class=&quot;headerlink&quot; title=&quot;0x00 vector 的初始化&quot;&gt;&lt;/a&gt;0x00 vector 的初始化&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v2(10); //初始化size为10可以避免数组动态增长的时候不断的分配内存
//或者vec.reserve(10); 功能同上

int  v1[10] = {0,1,0,0,3,0,0,4,4,4};
vector&amp;lt;int&amp;gt; v3(&amp;amp;v1[0],&amp;amp;v1[9]);//原始数组的元素指针可以作为迭代器来使用
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x01-使用迭代器访问元素&quot;&gt;&lt;a href=&quot;#0x01-使用迭代器访问元素&quot; class=&quot;headerlink&quot; title=&quot;0x01. 使用迭代器访问元素&quot;&gt;&lt;/a&gt;0x01. 使用迭代器访问元素&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt;::iterator it;

for(it=vec.begin();it!=vec.end();it++)

cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x02-和其他容器都类似，支持begin和end获取首尾指针&quot;&gt;&lt;a href=&quot;#0x02-和其他容器都类似，支持begin和end获取首尾指针&quot; class=&quot;headerlink&quot; title=&quot;0x02 和其他容器都类似，支持begin和end获取首尾指针&quot;&gt;&lt;/a&gt;0x02 和其他容器都类似，支持begin和end获取首尾指针&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//传入sort函数
sort(vec.begin(), vec.end(), Cmp);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x03-获取首尾元素和大小情况&quot;&gt;&lt;a href=&quot;#0x03-获取首尾元素和大小情况&quot; class=&quot;headerlink&quot; title=&quot;0x03 获取首尾元素和大小情况&quot;&gt;&lt;/a&gt;0x03 获取首尾元素和大小情况&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vec.front(); vec.back(); vec.size()； vec.empty();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x04-元素的插入和删除&quot;&gt;&lt;a href=&quot;#0x04-元素的插入和删除&quot; class=&quot;headerlink&quot; title=&quot;0x04 元素的插入和删除&quot;&gt;&lt;/a&gt;0x04 元素的插入和删除&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//在尾部增加和删除元素

vec.push_back();

vec.pop_back(); //可用来模仿stack和quene

vec.clear() ; //清除元素

vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;

// erase the 6th element
myvector.erase (myvector.begin()+5);

// erase the first 3 elements:
myvector.erase (myvector.begin(),myvector.begin()+3); //其实一般都是左闭右开 &amp;lt;=  &amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x05-常用算法&quot;&gt;&lt;a href=&quot;#0x05-常用算法&quot; class=&quot;headerlink&quot; title=&quot;0x05 常用算法&quot;&gt;&lt;/a&gt;0x05 常用算法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//1. sort

sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大).

//可以通过重写排序比较函数按照降序比较，如下：

//定义排序比较函数：

bool Comp(const int &amp;amp;a,const int &amp;amp;b)
{
    return a&amp;gt;b;
}
//调用时:
sort(vec.begin(),vec.end(),Comp)，这样就降序排序。其他类型的一样，    总之最后返回bool值就行

//2. reverse
reverse(vec.begin(),vec.end());将元素翻转
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;PS-发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot;&gt;&lt;a href=&quot;#PS-发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot; class=&quot;headerlink&quot; title=&quot;PS: 发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot;&gt;&lt;/a&gt;PS: 发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;www.cplusplus.com/reference/vector/vector&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;晚安 ~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;a href=&quot;#其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot; class=&quot;headerlink&quot; title=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;/a&gt;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&lt;/h2&gt;&lt;h4 id=&quot;Note：&quot;&gt;&lt;a href=&quot;#Note：&quot; class=&quot;headerlink&quot; title=&quot;Note：&quot;&gt;&lt;/a&gt;Note：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量使用reserve来减少不必要的内存分配次数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原则：尽量使用empty()而不是size()==0 来判断容器是否为空&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>hexo本地博客系统以及github page建博客流程</title>
    <link href="http://yoursite.com/2016/05/04/hexo%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8Agithub-page%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/05/04/hexo本地博客系统以及github-page建博客流程/</id>
    <published>2016-05-04T04:02:15.000Z</published>
    <updated>2016-05-04T04:26:24.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;a href=&quot;#大概记录下搭建这个博客的流程&quot; class=&quot;headerlink&quot; title=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;/a&gt;大概记录下搭建这个博客的流程&lt;/h2&gt;&lt;h3 id=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;a href=&quot;#这里只提大体流程，详细步骤可以参考下面的参考文章&quot; class=&quot;headerlink&quot; title=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;/a&gt;这里只提大体流程，详细步骤可以参考下面的参考文章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在github上申请新建一个repo，注意命名规范，这个会涉及到以后访问博客的url。这个repo就是以后博客的文章存放的地方&lt;/li&gt;
&lt;li&gt;搭建本地hexo博客系统。因为正常的流程都是从本地写好文章，部署到上面的repo就可以的。hexo系统可以方便地在本地写，支持命令行，还可以预览。文章本地写好之后就可以通过hexo直接部署到repo。&lt;/li&gt;
&lt;li&gt;配置hexo的部署需要在guthub网站上面配置ssh，然后在hexo里面的_config.yml填上你的仓库地址，第一次命令行部署需要填写github用户名和密码。&lt;/li&gt;
&lt;li&gt;可以自己更换一个博客的主题，需要配置一下config.yml，具体见下面的参考文章&lt;/li&gt;
&lt;li&gt;图片较多的话建议使用图床，我看其他教程里面七牛的多，试了下感觉还蛮好~~&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h3 id=&quot;写博客流程&quot;&gt;&lt;a href=&quot;#写博客流程&quot; class=&quot;headerlink&quot; title=&quot;写博客流程&quot;&gt;&lt;/a&gt;写博客流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;命令行进入博客的目录&lt;/li&gt;
&lt;li&gt;hexo new ‘文章标题’ ， 这时会在source/_post里面生成对应的文件夹和.md ，文件夹是用来存放此文章里面的资源的，例如图片&lt;/li&gt;
&lt;li&gt;编辑md文件，这个就是以后要发布的文章的内容，注意是按照Markdown语法来写的html，可以使用markdown编辑器，注意标记和内容之间的空格 和行之间空行&lt;/li&gt;
&lt;li&gt;hexo g （generate）， 将上面编辑的md生成html&lt;/li&gt;
&lt;li&gt;hexo s  （server），启动本地服务器预览文章， localhost：4000&lt;/li&gt;
&lt;li&gt;hexo d （deploy）预览无疑之后发布 ， 然后在 XXX.github.io里面就能看到写好的文章啦~&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h3&gt;&lt;p&gt;[1]. &lt;a href=&quot;http://www.jianshu.com/p/ecd51e8ef2fa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/ecd51e8ef2fa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;http://www.jianshu.com/p/05289a4bc8b2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/05289a4bc8b2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]. ..&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;a href=&quot;#大概记录下搭建这个博客的流程&quot; class=&quot;headerlink&quot; title=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;/a&gt;大概记录下搭建这个博客的流程&lt;/h2&gt;&lt;h3 id=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;a href=&quot;#这里只提大体流程，详细步骤可以参考下面的参考文章&quot; class=&quot;headerlink&quot; title=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;/a&gt;这里只提大体流程，详细步骤可以参考下面的参考文章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在github上申请新建一个repo，注意命名规范，这个会涉及到以后访问博客的url。这个repo就是以后博客的文章存放的地方&lt;/li&gt;
&lt;li&gt;搭建本地hexo博客系统。因为正常的流程都是从本地写好文章，部署到上面的repo就可以的。hexo系统可以方便地在本地写，支持命令行，还可以预览。文章本地写好之后就可以通过hexo直接部署到repo。&lt;/li&gt;
&lt;li&gt;配置hexo的部署需要在guthub网站上面配置ssh，然后在hexo里面的_config.yml填上你的仓库地址，第一次命令行部署需要填写github用户名和密码。&lt;/li&gt;
&lt;li&gt;可以自己更换一个博客的主题，需要配置一下config.yml，具体见下面的参考文章&lt;/li&gt;
&lt;li&gt;图片较多的话建议使用图床，我看其他教程里面七牛的多，试了下感觉还蛮好~~&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>读研之经历</title>
    <link href="http://yoursite.com/2016/05/04/%E8%AF%BB%E7%A0%94%E4%B9%8B%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2016/05/04/读研之经历/</id>
    <published>2016-05-04T03:30:23.000Z</published>
    <updated>2016-05-04T03:47:41.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;a href=&quot;#熬到了研一下，忍不住想说下我的感受&quot; class=&quot;headerlink&quot; title=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;/a&gt;熬到了研一下，忍不住想说下我的感受&lt;/h2&gt;&lt;p&gt;在这里读硕的切身感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做什么东西都是自己做，遇到问题自己解决，问别人？ 抱歉，他们不做这个这个东西，只有你一个人在做。。&lt;/li&gt;
&lt;li&gt;不要奢望有个牛人带你，因为实在没有。。&lt;/li&gt;
&lt;li&gt;做paper的时候，从选paper到读只有你一个人在做。。老师不会帮你挑paper，读完也没有人交流，这就完事儿，这叫做研究？excuse me？真心为自己的未来担忧&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一直觉得，为别人干活的动力有两个：一是收获很多技术上的成长，得到牛人的指导。二是没有什么收获，但是可以得到很多钱。。 所以，抱歉我还是默默去刷leetcode了&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;a href=&quot;#熬到了研一下，忍不住想说下我的感受&quot; class=&quot;headerlink&quot; title=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;/a&gt;熬到了研一下，忍不住想说下我的感受&lt;/h2&gt;&lt;p&gt;在这里读硕的切身感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做什么东西都是自己做，遇到问题自己解决，问别人？ 抱歉，他们不做这个这个东西，只有你一个人在做。。&lt;/li&gt;
&lt;li&gt;不要奢望有个牛人带你，因为实在没有。。&lt;/li&gt;
&lt;li&gt;做paper的时候，从选paper到读只有你一个人在做。。老师不会帮你挑paper，读完也没有人交流，这就完事儿，这叫做研究？excuse me？真心为自己的未来担忧
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Done!</title>
    <link href="http://yoursite.com/2016/04/26/Done/"/>
    <id>http://yoursite.com/2016/04/26/Done/</id>
    <published>2016-04-26T08:10:01.000Z</published>
    <updated>2016-04-26T08:48:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;a href=&quot;#“费了半天劲终于把这个东东弄好了，那么问题来了”&quot; class=&quot;headerlink&quot; title=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;/a&gt;“费了半天劲终于把这个东东弄好了，那么问题来了”&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;OMG.jpg&quot; alt=&quot;已哭瞎&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;老板交给我的活儿还没有动。。&lt;/li&gt;
&lt;li&gt;明天要给老板交周报。。&lt;/li&gt;
&lt;li&gt;好了，我去干活啦（咻~~）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;来测试下代码&quot;&gt;&lt;a href=&quot;#来测试下代码&quot; class=&quot;headerlink&quot; title=&quot;来测试下代码&quot;&gt;&lt;/a&gt;来测试下代码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;来测试下图片&quot;&gt;&lt;a href=&quot;#来测试下图片&quot; class=&quot;headerlink&quot; title=&quot;来测试下图片**&quot;&gt;&lt;/a&gt;来测试下图片**&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;tuo.jpg&quot; alt=&quot;哎呀，图片挂啦&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;a href=&quot;#“费了半天劲终于把这个东东弄好了，那么问题来了”&quot; class=&quot;headerlink&quot; title=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;/a&gt;“费了半天劲终于把这个东东弄好了，那么问题来了”&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;OMG.jpg&quot; alt=&quot;已哭瞎&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小冉是不是该睡觉了</title>
  <subtitle>是时候理个发了吧</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2016-07-19T09:38:51.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>BetterAA</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《python网络数据采集》学习笔记-NLTK</title>
    <link href="http://yoursite.com/2016/07/19/%E3%80%8Apython%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-NLTK/"/>
    <id>http://yoursite.com/2016/07/19/《python网络数据采集》学习笔记-NLTK/</id>
    <published>2016-07-19T09:23:59.000Z</published>
    <updated>2016-07-19T09:38:51.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;《python网络数据采集》-一书中自然语言处理基础学习&quot;&gt;&lt;a href=&quot;#《python网络数据采集》-一书中自然语言处理基础学习&quot; class=&quot;headerlink&quot; title=&quot;《python网络数据采集》 一书中自然语言处理基础学习&quot;&gt;&lt;/a&gt;《python网络数据采集》 一书中自然语言处理基础学习&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# from nltk import word_tokenize
from nltk import Text
#用NLTK做统计分析一般都是从Text对象开始的
tokens = word_tokenize(&amp;quot;here is some not very interesting text is&amp;quot;)
text = Text(tokens)
#Text对象的长度就是 单词的个数
print len(text)
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;from nltk import FreqDist #计算词频
from nltk.book import text6 #用的是自带的基本书，一共有10本，这里用第6本
fdist = FreqDist(text6)
fdist.most_common(5)  #直接找出按照词频排前10的单词
fdist[&amp;quot;Grail&amp;quot;]        #也可以直接找出某个词的词频
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h3 id=&quot;-1&quot;&gt;&lt;a href=&quot;#-1&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#直接调用n-gram模型
from nltk import ngrams
fourgrams = ngrams(text6,4)
#词频类也可以对n-gram词典进行统计词频
fourgramsDist = FreqDist(fourgrams)
#直接查找这个4序列的频率
fourgramsDist[(&amp;quot;father&amp;quot;,&amp;quot;smelt&amp;quot;,&amp;quot;of&amp;quot;,&amp;quot;elderberries&amp;quot;)] #输出1，表示出现了一次
for fourgram in fourgrams:
if fourgram[0] == &amp;quot;cocount&amp;quot;: #直接判断4-gram列表里面的第一个词是cocount的
    print(fourgram)    
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h3 id=&quot;-2&quot;&gt;&lt;a href=&quot;#-2&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h3&gt;&lt;pre&gt;&lt;code&gt;#词性分析
from nltk import pos_tag
text = word_tokenize(&amp;quot;The dust was thick so he has to dust&amp;quot;)
pos_tag(text)  #是一个列表[] ,列表里面的每一个都是一个tuple二元组
#DT，NN等都是词性标记的缩写，在《python网络数据采集》一书的P116
#这里dust出现了两次，词性不同，识别方式是通过形式语言的“上下文无关文法”，形式语言的上下文无关文法确定的是一个词性后面可以跟哪些词性

//OUT
[(&amp;apos;The&amp;apos;, &amp;apos;DT&amp;apos;),
(&amp;apos;dust&amp;apos;, &amp;apos;NN&amp;apos;),
(&amp;apos;was&amp;apos;, &amp;apos;VBD&amp;apos;),    
(&amp;apos;thick&amp;apos;, &amp;apos;RB&amp;apos;),
(&amp;apos;so&amp;apos;, &amp;apos;RB&amp;apos;), 
(&amp;apos;he&amp;apos;, &amp;apos;PRP&amp;apos;),
(&amp;apos;has&amp;apos;, &amp;apos;VBZ&amp;apos;),
(&amp;apos;to&amp;apos;, &amp;apos;TO&amp;apos;),
(&amp;apos;dust&amp;apos;, &amp;apos;VB&amp;apos;)]
&lt;/code&gt;&lt;/pre&gt;&lt;!-- more --&gt;
&lt;h2 id=&quot;-3&quot;&gt;&lt;a href=&quot;#-3&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;&lt;pre&gt;&lt;code&gt;#对于词性的应用，找出一段文字中作为名词而不是动词的“google”
from nltk import sent_tokenize
#sent_tokenize 用来将一段话分解成句子， 而word_tokenize是将一句话分词
sentences = sent_tokenize(&amp;quot;Google is one of the best companies in the world. I constantly google myself to see what i&amp;apos;m to.&amp;quot;)
nouns = [&amp;apos;NN&amp;apos;,&amp;apos;NNS&amp;apos;,&amp;apos;NNP&amp;apos;,&amp;apos;NNPS&amp;apos;] #将词性标注中属于名词的列出来，统计为名词
for sentence in sentences:
    if &amp;apos;google&amp;apos; in sentence.lower(): #判断句子中有没有google一词
        taggedWords = pos_tag(word_tokenize(sentence)) #
        for word in taggedWords: #每个是二元组
            if word[0].lower() == &amp;quot;google&amp;quot; and word[1] in nouns:
                print(sentence) #打印出包含名词google的句子

#OUT
Google is one of the best companies in the world.
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;自然语言中的许多-歧义问题-都可以用-pos-tag-解决，不只是搜索-目标单词或短语，而是搜索【带标记的目标单词和短语】&quot;&gt;&lt;a href=&quot;#自然语言中的许多-歧义问题-都可以用-pos-tag-解决，不只是搜索-目标单词或短语，而是搜索【带标记的目标单词和短语】&quot; class=&quot;headerlink&quot; title=&quot;自然语言中的许多  歧义问题  都可以用 pos_tag 解决，不只是搜索 目标单词或短语，而是搜索【带标记的目标单词和短语】&quot;&gt;&lt;/a&gt;自然语言中的许多  歧义问题  都可以用 pos_tag 解决，不只是搜索 目标单词或短语，而是搜索【带标记的目标单词和短语】&lt;/h3&gt;</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;《python网络数据采集》-一书中自然语言处理基础学习&quot;&gt;&lt;a href=&quot;#《python网络数据采集》-一书中自然语言处理基础学习&quot; class=&quot;headerlink&quot; title=&quot;《python网络数据采集》 一书中自然语言处理基础学习&quot;&gt;&lt;/a&gt;《python网络数据采集》 一书中自然语言处理基础学习&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;# from nltk import word_tokenize
from nltk import Text
#用NLTK做统计分析一般都是从Text对象开始的
tokens = word_tokenize(&amp;quot;here is some not very interesting text is&amp;quot;)
text = Text(tokens)
#Text对象的长度就是 单词的个数
print len(text)
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="NLTK" scheme="http://yoursite.com/tags/NLTK/"/>
    
  </entry>
  
  <entry>
    <title>JAVA hashMap and treeMap</title>
    <link href="http://yoursite.com/2016/07/19/JAVA-hashMap-and-treeMap/"/>
    <id>http://yoursite.com/2016/07/19/JAVA-hashMap-and-treeMap/</id>
    <published>2016-07-19T08:28:16.000Z</published>
    <updated>2016-07-19T08:46:20.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;这里简单介绍下这两个map&quot;&gt;&lt;a href=&quot;#这里简单介绍下这两个map&quot; class=&quot;headerlink&quot; title=&quot;这里简单介绍下这两个map&quot;&gt;&lt;/a&gt;这里简单介绍下这两个map&lt;/h2&gt;&lt;p&gt;也是一些我从网上收集的内容，有些测过有些没测，可能有不对的地方 ：D&lt;/p&gt;
&lt;h3 id=&quot;关于hashMap和-treeMap&quot;&gt;&lt;a href=&quot;#关于hashMap和-treeMap&quot; class=&quot;headerlink&quot; title=&quot;关于hashMap和 treeMap&quot;&gt;&lt;/a&gt;关于hashMap和 treeMap&lt;/h3&gt;&lt;p&gt;HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序（内部实现应该是红黑树），如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。&lt;/p&gt;
&lt;h3 id=&quot;性能对比：&quot;&gt;&lt;a href=&quot;#性能对比：&quot; class=&quot;headerlink&quot; title=&quot;性能对比：&quot;&gt;&lt;/a&gt;性能对比：&lt;/h3&gt;&lt;p&gt;两种常规Map性能&lt;br&gt;HashMap：适用于在Map中插入、删除和定位元素。&lt;br&gt;Treemap：适用于按自然顺序或自定义顺序遍历键(key)。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;p&gt;HashMap通常比TreeMap快一点(树和哈希表的数据结构使然)，建议多使用HashMap，在需要排序的Map时候才用TreeMap。&lt;/p&gt;
&lt;h3 id=&quot;用法：&quot;&gt;&lt;a href=&quot;#用法：&quot; class=&quot;headerlink&quot; title=&quot;用法：&quot;&gt;&lt;/a&gt;用法：&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;Hashtable&amp;lt;String, String&amp;gt; map = new Hashtable&amp;lt;String, String&amp;gt;();
map.put(&amp;quot;a&amp;quot;, &amp;quot;aaa&amp;quot;);
//遍历写法（推荐下面的写法，效率高些）
//遍历key
for (String key : map.keySet()) {
    value = map.get(key);
}
//遍历整个键值对 :一个entry
for (Entry&amp;lt;String, String&amp;gt; entry: map.entrySet()) {
    key = entry.getKey();
    value = entry.getValue();
}
//遍历value
for (String value : map.values()) {

}
//判断是否存在key
map. containsKey(test)
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;这里简单介绍下这两个map&quot;&gt;&lt;a href=&quot;#这里简单介绍下这两个map&quot; class=&quot;headerlink&quot; title=&quot;这里简单介绍下这两个map&quot;&gt;&lt;/a&gt;这里简单介绍下这两个map&lt;/h2&gt;&lt;p&gt;也是一些我从网上收集的内容，有些测过有些没测，可能有不对的地方 ：D&lt;/p&gt;
&lt;h3 id=&quot;关于hashMap和-treeMap&quot;&gt;&lt;a href=&quot;#关于hashMap和-treeMap&quot; class=&quot;headerlink&quot; title=&quot;关于hashMap和 treeMap&quot;&gt;&lt;/a&gt;关于hashMap和 treeMap&lt;/h3&gt;&lt;p&gt;HashMap通过hashcode对其内容进行快速查找，而 TreeMap中所有的元素都保持着某种固定的顺序（内部实现应该是红黑树），如果你需要得到一个有序的结果你就应该使用TreeMap（HashMap中元素的排列顺序是不固定的）。&lt;/p&gt;
&lt;h3 id=&quot;性能对比：&quot;&gt;&lt;a href=&quot;#性能对比：&quot; class=&quot;headerlink&quot; title=&quot;性能对比：&quot;&gt;&lt;/a&gt;性能对比：&lt;/h3&gt;&lt;p&gt;两种常规Map性能&lt;br&gt;HashMap：适用于在Map中插入、删除和定位元素。&lt;br&gt;Treemap：适用于按自然顺序或自定义顺序遍历键(key)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="map" scheme="http://yoursite.com/tags/map/"/>
    
  </entry>
  
  <entry>
    <title>python+BeautifulSoup 爬虫 正则 简单示例</title>
    <link href="http://yoursite.com/2016/07/16/python-BeautifulSoup-%E7%88%AC%E8%99%AB-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B/"/>
    <id>http://yoursite.com/2016/07/16/python-BeautifulSoup-爬虫-简单示例/</id>
    <published>2016-07-16T13:52:52.000Z</published>
    <updated>2016-07-16T14:01:01.000Z</updated>
    
    <content type="html">&lt;p&gt;##这里是直接用源码+重要注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-*- coding:utf-8 -*-
from urllib import urlopen
from bs4 import BeautifulSoup
import requests
import re
import time

url = &amp;quot;&amp;quot;
domain = &amp;quot;&amp;quot;

sessions = requests.Session()
#注意; 这里没有对编码处理，输出中文字符乱码。。decode（“utf-8”）
&lt;/code&gt;&lt;/pre&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;pre&gt;&lt;code&gt;#还有别的header也可以加
header = {&amp;quot;User-Agent&amp;quot;:&amp;quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_4) AppleWebKit/600.7.12 (KHTML, like Gecko) Version/8.0.7 Safari/600.7.12&amp;quot;}
req = sessions.get(url,headers=header)

bsObj = BeautifulSoup(req.text)
#可以直接找tbody，省的再先找table，但是这样没有那样稳妥
#findAll和find函数都是的第一个都是标签的类型，如p，div，后面的{}是属性集合
#第一个标签类型也可以不填，那就都找
table_tbody = bsObj.find(&amp;quot;tbody&amp;quot;,{&amp;quot;style&amp;quot;:&amp;quot;table-layout:fixed;&amp;quot;})
trs = table_tbody.findAll(&amp;quot;tr&amp;quot;,{&amp;quot;class&amp;quot;:&amp;quot;tr3 t_one&amp;quot;})

subURLs = []
for tr in trs:
_url = tr.find(&amp;quot;a&amp;quot;,{&amp;quot;target&amp;quot;:&amp;quot;_blank&amp;quot;}).attrs[&amp;quot;href”]  #找到标签后用attrs可以找到属性
subURLs.append(domain+_url)

#print &amp;apos;\n&amp;apos;.join(subURLs)
#边爬数据边写，避免中途异常后无数据
out = open(&amp;quot;./out&amp;quot;,&amp;quot;w&amp;quot;)

real_url = []
for _url in subURLs:
#记得异常处理
try:
    #这里避免请求太频繁，因此每次暂停2秒
    time.sleep(2)
    print &amp;apos;In url: &amp;apos;+_url
    _req = sessions.get(_url,headers= header)
    _bsObj = BeautifulSoup(_req.text)
    _a = _bsObj.find(&amp;quot;div&amp;quot;,{&amp;quot;class&amp;quot;:&amp;quot;tpc_content do_not_catch&amp;quot;}).find(&amp;quot;a&amp;quot;,{&amp;quot;style&amp;quot;:&amp;quot;cursor:pointer&amp;quot;})
#_a.get_text() 可以得到a标签的文本
#（.*?）是正则里面的东西，可以匹配全部的内容，前面\’是’转义，此处我们的待匹配字符串是.src=.....’” style..
#我们要取到的是src后面...
    #real_url.append(re.findall(r&amp;apos;.src=\&amp;apos;(.*?)\&amp;apos;\&amp;quot; style&amp;apos;,str(_a))[0])  #转成字符串str处理
    out.write(re.findall(r&amp;apos;.src=\&amp;apos;(.*?)\&amp;apos;\&amp;quot; style&amp;apos;,str(_a))[0]+&amp;apos;\n&amp;apos;)
except:
    print &amp;apos;爬取失败&amp;apos;
finally:
    out.close()

out.close()
#out.write(&amp;apos;\n&amp;apos;.join(real_url))
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;p&gt;##这里是直接用源码+重要注释&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#-*- coding:utf-8 -*-
from urllib import urlopen
from bs4 import BeautifulSoup
import requests
import re
import time

url = &amp;quot;&amp;quot;
domain = &amp;quot;&amp;quot;

sessions = requests.Session()
#注意; 这里没有对编码处理，输出中文字符乱码。。decode（“utf-8”）
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/tags/%E7%88%AC%E8%99%AB/"/>
    
      <category term="BeautifulSoup" scheme="http://yoursite.com/tags/BeautifulSoup/"/>
    
      <category term="正则" scheme="http://yoursite.com/tags/%E6%AD%A3%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JAVA异常：Comparison method violates its general contract</title>
    <link href="http://yoursite.com/2016/07/05/JAVA%E5%BC%82%E5%B8%B8%EF%BC%9AComparison-method-violates-its-general-contract/"/>
    <id>http://yoursite.com/2016/07/05/JAVA异常：Comparison-method-violates-its-general-contract/</id>
    <published>2016-07-05T04:00:10.000Z</published>
    <updated>2016-07-05T04:23:09.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;异常描述&quot;&gt;&lt;a href=&quot;#异常描述&quot; class=&quot;headerlink&quot; title=&quot;异常描述&quot;&gt;&lt;/a&gt;异常描述&lt;/h2&gt;&lt;p&gt;java.lang.IllegalArgumentException: Comparison method violates its general contract!&lt;/p&gt;
&lt;h2 id=&quot;异常举例&quot;&gt;&lt;a href=&quot;#异常举例&quot; class=&quot;headerlink&quot; title=&quot;异常举例&quot;&gt;&lt;/a&gt;异常举例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
    public int compare(Integer o1, Integer o2) {  
        return o1 &amp;gt; o2 ? 1 : -1;// 错误的方式  
    }  
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;异常原因&quot;&gt;&lt;a href=&quot;#异常原因&quot; class=&quot;headerlink&quot; title=&quot;异常原因&quot;&gt;&lt;/a&gt;异常原因&lt;/h2&gt;&lt;p&gt;JDK7的sort函数实现变了，与旧版本的不同，存在兼容问题，可以查看下自己的compare函数实现有木有问题&lt;br&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;br&gt;新版本中对比较有约束条件，如果违反了约束条件就会抛出llegalArgumentException异常，JDK6中则忽略了这种情况，那么新的约束是啥子？&lt;br&gt;&lt;img src=&quot;compare.png&quot; alt=&quot;compare&quot;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;sgn(compare(x, y)) == -sgn(compare(y, x))&lt;/li&gt;
&lt;li&gt;((compare(x, y)&amp;gt;0) &amp;amp;&amp;amp; (compare(y, z)&amp;gt;0)) implies compare(x, z)&amp;gt;0&lt;/li&gt;
&lt;li&gt;compare(x, y)==0 implies that sgn(compare(x, z))==sgn(compare(y, z)) for all z&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，上面的异常举例就有问题了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;return x &amp;gt; y ? 1 : -1; 
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;当x == y时，sgn(compare(x, y))  = -1，-sgn(compare(y, x)) = 1，这违背了sgn(compare(x, y)) == -sgn(compare(y, x))约束。&lt;/p&gt;
&lt;h2 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法&quot; class=&quot;headerlink&quot; title=&quot;解决方法&quot;&gt;&lt;/a&gt;解决方法&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;JVM启动参数 增加 -Djava.util.Arrays.useLegacyMergeSort=true&lt;/li&gt;
&lt;li&gt;改动compare函数&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
public int compare(Integer o1, Integer o2) {  
// return o1 &amp;gt; o2 ? 1 : -1;  
return o1.compareTo(o2);// 正确的方式 
//或者 return  o1 &amp;gt;= o2 ? 1 : -1; 
}  
}); 
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;异常描述&quot;&gt;&lt;a href=&quot;#异常描述&quot; class=&quot;headerlink&quot; title=&quot;异常描述&quot;&gt;&lt;/a&gt;异常描述&lt;/h2&gt;&lt;p&gt;java.lang.IllegalArgumentException: Comparison method violates its general contract!&lt;/p&gt;
&lt;h2 id=&quot;异常举例&quot;&gt;&lt;a href=&quot;#异常举例&quot; class=&quot;headerlink&quot; title=&quot;异常举例&quot;&gt;&lt;/a&gt;异常举例&lt;/h2&gt;&lt;pre&gt;&lt;code&gt;Collections.sort(list, new Comparator&amp;lt;Integer&amp;gt;() {  
@Override  
    public int compare(Integer o1, Integer o2) {  
        return o1 &amp;gt; o2 ? 1 : -1;// 错误的方式  
    }  
});
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;异常原因&quot;&gt;&lt;a href=&quot;#异常原因&quot; class=&quot;headerlink&quot; title=&quot;异常原因&quot;&gt;&lt;/a&gt;异常原因&lt;/h2&gt;&lt;p&gt;JDK7的sort函数实现变了，与旧版本的不同，存在兼容问题，可以查看下自己的compare函数实现有木有问题&lt;br&gt;
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="异常" scheme="http://yoursite.com/tags/%E5%BC%82%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop hive 分区partition</title>
    <link href="http://yoursite.com/2016/06/15/Hadoop-hive-%E5%88%86%E5%8C%BApartition/"/>
    <id>http://yoursite.com/2016/06/15/Hadoop-hive-分区partition/</id>
    <published>2016-06-15T07:23:34.000Z</published>
    <updated>2016-06-15T08:09:42.000Z</updated>
    
    <content type="html">&lt;h3 id=&quot;Hive是啥子？&quot;&gt;&lt;a href=&quot;#Hive是啥子？&quot; class=&quot;headerlink&quot; title=&quot;Hive是啥子？&quot;&gt;&lt;/a&gt;Hive是啥子？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。（将输入的hql语句解析成待提交的job）&lt;/li&gt;
&lt;li&gt;本质是将SQL转换为MapReduce程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Hive-特点&quot;&gt;&lt;a href=&quot;#Hive-特点&quot; class=&quot;headerlink&quot; title=&quot;Hive 特点&quot;&gt;&lt;/a&gt;Hive 特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可扩展： 可自由扩展集群规模，一般无需重启服务&lt;/li&gt;
&lt;li&gt;延展性： 支持自定义函数&lt;/li&gt;
&lt;li&gt;容错性： 良好的容错性，节点出现问题SQL仍可完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;hive与Hadoop的关系&quot;&gt;&lt;a href=&quot;#hive与Hadoop的关系&quot; class=&quot;headerlink&quot; title=&quot;hive与Hadoop的关系&quot;&gt;&lt;/a&gt;hive与Hadoop的关系&lt;/h3&gt;&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;&lt;img src=&quot;hadoop-hive.jpg&quot; alt=&quot;hive与hadoop的关系&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;关于分区partition的概念&quot;&gt;&lt;a href=&quot;#关于分区partition的概念&quot; class=&quot;headerlink&quot; title=&quot;关于分区partition的概念&quot;&gt;&lt;/a&gt;关于分区partition的概念&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在Hive Select语句查询中一般会扫描整个表内容，会消耗很多时间做没必要的工作。有时候只需要扫描表中关心的一部分数据，因此建表时引入了partition概念&lt;/li&gt;
&lt;li&gt;分区表指的是在创建表时指定的partition的分区空间&lt;/li&gt;
&lt;li&gt;如果需要创建有分区的表，需要在create表的时候调用可选参数partitioned by，&lt;/li&gt;
&lt;li&gt;一个表可以拥有一个或者多个分区，每个分区以文件夹的形式单独存在表文件夹的目录下。&lt;/li&gt;
&lt;li&gt;分区是以字段的形式在表结构中存在，通过describe table命令可以查看到字段存在，但是该字段不存放实际的数据内容，仅仅是分区的表示。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;分区建立&quot;&gt;&lt;a href=&quot;#分区建立&quot; class=&quot;headerlink&quot; title=&quot;分区建立&quot;&gt;&lt;/a&gt;分区建立&lt;/h4&gt;&lt;p&gt; 分区建表分为2种，一种是单分区，也就是说在表文件夹目录下只有一级文件夹目录。另外一种是多分区，表文件夹下出现多文件夹嵌套模式。&lt;/p&gt;
&lt;p&gt;  a. 单分区建表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table day_table (id int, content string) partitioned by (dt string);单分区表，按天分区，在表结构中存在id，content，dt三列。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;  b. 双分区建表语句：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;create table day_hour_table (id int, content string) partitioned by (dt string, hour string);双分区表，按天和小时分区，在表结构中新增加了dt和hour两列。
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;添加分区&quot;&gt;&lt;a href=&quot;#添加分区&quot; class=&quot;headerlink&quot; title=&quot;添加分区&quot;&gt;&lt;/a&gt;添加分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ALTER TABLE day_table ADD PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;08&amp;apos;) location &amp;apos;/path/pv1.txt&amp;apos; PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;09&amp;apos;) location &amp;apos;/path/pv2.txt&amp;apos;;    
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;删除分区&quot;&gt;&lt;a href=&quot;#删除分区&quot; class=&quot;headerlink&quot; title=&quot;删除分区&quot;&gt;&lt;/a&gt;删除分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;ALTER TABLE day_hour_table DROP PARTITION (dt=&amp;apos;2008-08-08&amp;apos;, hour=&amp;apos;09&amp;apos;);    
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;数据加载进分区&quot;&gt;&lt;a href=&quot;#数据加载进分区&quot; class=&quot;headerlink&quot; title=&quot;数据加载进分区&quot;&gt;&lt;/a&gt;数据加载进分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;LOAD DATA INPATH &amp;apos;/user/pv.txt&amp;apos; INTO TABLE day_hour_table PARTITION(dt=&amp;apos;2008-08- 08&amp;apos;, hour=&amp;apos;08&amp;apos;);

LOAD DATA local INPATH &amp;apos;/user/hua/*&amp;apos; INTO TABLE day_hour partition(dt=&amp;apos;2010-07- 07&amp;apos;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;   当数据被加载至表中时，不会对数据进行任何转换。Load操作只是将数据复制至Hive表对应的位置。数据加载时在表下自动创建一个目录，文件存放在该分区下。&lt;/p&gt;
&lt;h4 id=&quot;基于分区的查询语句&quot;&gt;&lt;a href=&quot;#基于分区的查询语句&quot; class=&quot;headerlink&quot; title=&quot;基于分区的查询语句&quot;&gt;&lt;/a&gt;基于分区的查询语句&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;SELECT day_table.* FROM day_table WHERE day_table.dt&amp;gt;= &amp;apos;2008-08-08&amp;apos;;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;查看表的分区&quot;&gt;&lt;a href=&quot;#查看表的分区&quot; class=&quot;headerlink&quot; title=&quot;查看表的分区&quot;&gt;&lt;/a&gt;查看表的分区&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;hive&amp;gt; 
show partitions day_hour_table; 

OK 
dt=2008-08-08/hour=08 
dt=2008-08-08/hour=09 
dt=2008-08-09/hour=09;
...
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;总结&quot;&gt;&lt;a href=&quot;#总结&quot; class=&quot;headerlink&quot; title=&quot;总结&quot;&gt;&lt;/a&gt;总结&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;总的说来partition就是辅助查询，缩小查询范围，加快数据的检索速度和对数据按照一定的规格和条件进行管理。&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hive是啥子？&quot;&gt;&lt;a href=&quot;#Hive是啥子？&quot; class=&quot;headerlink&quot; title=&quot;Hive是啥子？&quot;&gt;&lt;/a&gt;Hive是啥子？&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供类SQL查询功能。（将输入的hql语句解析成待提交的job）&lt;/li&gt;
&lt;li&gt;本质是将SQL转换为MapReduce程序&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;Hive-特点&quot;&gt;&lt;a href=&quot;#Hive-特点&quot; class=&quot;headerlink&quot; title=&quot;Hive 特点&quot;&gt;&lt;/a&gt;Hive 特点&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;可扩展： 可自由扩展集群规模，一般无需重启服务&lt;/li&gt;
&lt;li&gt;延展性： 支持自定义函数&lt;/li&gt;
&lt;li&gt;容错性： 良好的容错性，节点出现问题SQL仍可完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;hive与Hadoop的关系&quot;&gt;&lt;a href=&quot;#hive与Hadoop的关系&quot; class=&quot;headerlink&quot; title=&quot;hive与Hadoop的关系&quot;&gt;&lt;/a&gt;hive与Hadoop的关系&lt;/h3&gt;
    
    </summary>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="hive" scheme="http://yoursite.com/tags/hive/"/>
    
  </entry>
  
  <entry>
    <title>c++ snippets</title>
    <link href="http://yoursite.com/2016/05/10/c-snippets/"/>
    <id>http://yoursite.com/2016/05/10/c-snippets/</id>
    <published>2016-05-10T14:50:52.000Z</published>
    <updated>2016-05-10T16:23:15.000Z</updated>
    
    <content type="html">&lt;h4 id=&quot;Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot;&gt;&lt;a href=&quot;#Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot; class=&quot;headerlink&quot; title=&quot;Note: 带符号的整数n，进行-1乘n操作时，小心n=-2147483648，这时-1*n会溢出，可以 n++-1；&quot;&gt;&lt;/a&gt;Note: 带符号的整数n，进行-1乘n操作时，小心n=-2147483648，这时-1*n会溢出，可以 n++-1；&lt;/h4&gt;&lt;h4 id=&quot;1-c-str-：生成一个const-char-指针，指向以空字符终止的数组。&quot;&gt;&lt;a href=&quot;#1-c-str-：生成一个const-char-指针，指向以空字符终止的数组。&quot; class=&quot;headerlink&quot; title=&quot;1. c_str()：生成一个const char*指针，指向以空字符终止的数组。&quot;&gt;&lt;/a&gt;1. c_str()：生成一个const char*指针，指向以空字符终止的数组。&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;char* c=new char[20];
string s=&amp;quot;1234&amp;quot;;
//c = s.c_str(); 
strcpy(c,s.c_str());
cout&amp;lt;&amp;lt;c&amp;lt;&amp;lt;endl; //输出：1234
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;2-将字符串转换为数字&quot;&gt;&lt;a href=&quot;#2-将字符串转换为数字&quot; class=&quot;headerlink&quot; title=&quot;2.将字符串转换为数字&quot;&gt;&lt;/a&gt;2.将字符串转换为数字&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;string source = &amp;quot;123&amp;quot;;
atoi(source.c_str());
&lt;/code&gt;&lt;/pre&gt;</content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot;&gt;&lt;a href=&quot;#Note-带符号的整数n，进行-1乘n操作时，小心n-2147483648，这时-1-n会溢出，可以-n-1；&quot; class=&quot;h
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="snippet" scheme="http://yoursite.com/tags/snippet/"/>
    
  </entry>
  
  <entry>
    <title>c++ vector容器常用操作</title>
    <link href="http://yoursite.com/2016/05/09/c-vector%E5%AE%B9%E5%99%A8%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2016/05/09/c-vector容器常用操作/</id>
    <published>2016-05-08T16:20:46.000Z</published>
    <updated>2016-05-08T17:03:04.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;a href=&quot;#其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot; class=&quot;headerlink&quot; title=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;/a&gt;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&lt;/h2&gt;&lt;h4 id=&quot;Note：&quot;&gt;&lt;a href=&quot;#Note：&quot; class=&quot;headerlink&quot; title=&quot;Note：&quot;&gt;&lt;/a&gt;Note：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量使用reserve来减少不必要的内存分配次数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原则：尽量使用empty()而不是size()==0 来判断容器是否为空&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h4 id=&quot;0x00-vector-的初始化&quot;&gt;&lt;a href=&quot;#0x00-vector-的初始化&quot; class=&quot;headerlink&quot; title=&quot;0x00 vector 的初始化&quot;&gt;&lt;/a&gt;0x00 vector 的初始化&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt; v2(10); //初始化size为10可以避免数组动态增长的时候不断的分配内存
//或者vec.reserve(10); 功能同上

int  v1[10] = {0,1,0,0,3,0,0,4,4,4};
vector&amp;lt;int&amp;gt; v3(&amp;amp;v1[0],&amp;amp;v1[9]);//原始数组的元素指针可以作为迭代器来使用
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x01-使用迭代器访问元素&quot;&gt;&lt;a href=&quot;#0x01-使用迭代器访问元素&quot; class=&quot;headerlink&quot; title=&quot;0x01. 使用迭代器访问元素&quot;&gt;&lt;/a&gt;0x01. 使用迭代器访问元素&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vector&amp;lt;int&amp;gt;::iterator it;

for(it=vec.begin();it!=vec.end();it++)

cout&amp;lt;&amp;lt;*it&amp;lt;&amp;lt;endl;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x02-和其他容器都类似，支持begin和end获取首尾指针&quot;&gt;&lt;a href=&quot;#0x02-和其他容器都类似，支持begin和end获取首尾指针&quot; class=&quot;headerlink&quot; title=&quot;0x02 和其他容器都类似，支持begin和end获取首尾指针&quot;&gt;&lt;/a&gt;0x02 和其他容器都类似，支持begin和end获取首尾指针&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//传入sort函数
sort(vec.begin(), vec.end(), Cmp);
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x03-获取首尾元素和大小情况&quot;&gt;&lt;a href=&quot;#0x03-获取首尾元素和大小情况&quot; class=&quot;headerlink&quot; title=&quot;0x03 获取首尾元素和大小情况&quot;&gt;&lt;/a&gt;0x03 获取首尾元素和大小情况&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;vec.front(); vec.back(); vec.size()； vec.empty();
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x04-元素的插入和删除&quot;&gt;&lt;a href=&quot;#0x04-元素的插入和删除&quot; class=&quot;headerlink&quot; title=&quot;0x04 元素的插入和删除&quot;&gt;&lt;/a&gt;0x04 元素的插入和删除&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//在尾部增加和删除元素

vec.push_back();

vec.pop_back(); //可用来模仿stack和quene

vec.clear() ; //清除元素

vec.insert(vec.begin()+i,a);在第i+1个元素前面插入a;

// erase the 6th element
myvector.erase (myvector.begin()+5);

// erase the first 3 elements:
myvector.erase (myvector.begin(),myvector.begin()+3); //其实一般都是左闭右开 &amp;lt;=  &amp;lt;
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&quot;0x05-常用算法&quot;&gt;&lt;a href=&quot;#0x05-常用算法&quot; class=&quot;headerlink&quot; title=&quot;0x05 常用算法&quot;&gt;&lt;/a&gt;0x05 常用算法&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;//1. sort

sort(vec.begin(),vec.end());(默认是按升序排列,即从小到大).

//可以通过重写排序比较函数按照降序比较，如下：

//定义排序比较函数：

bool Comp(const int &amp;amp;a,const int &amp;amp;b)
{
    return a&amp;gt;b;
}
//调用时:
sort(vec.begin(),vec.end(),Comp)，这样就降序排序。其他类型的一样，    总之最后返回bool值就行

//2. reverse
reverse(vec.begin(),vec.end());将元素翻转
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;PS-发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot;&gt;&lt;a href=&quot;#PS-发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot; class=&quot;headerlink&quot; title=&quot;PS: 发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&quot;&gt;&lt;/a&gt;PS: 发现这里的文档很详细，还有示例代码参考，这里没有的可以参考下：&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;http://www.cplusplus.com/reference/vector/vector/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;www.cplusplus.com/reference/vector/vector&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;晚安 ~~&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;a href=&quot;#其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot; class=&quot;headerlink&quot; title=&quot;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&quot;&gt;&lt;/a&gt;其实这东西从来都是屯在我的EverNote里的，今天又用到了，还是整理出来吧。。&lt;/h2&gt;&lt;h4 id=&quot;Note：&quot;&gt;&lt;a href=&quot;#Note：&quot; class=&quot;headerlink&quot; title=&quot;Note：&quot;&gt;&lt;/a&gt;Note：&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;尽量使用reserve来减少不必要的内存分配次数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;原则：尽量使用empty()而不是size()==0 来判断容器是否为空&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
      <category term="vector" scheme="http://yoursite.com/tags/vector/"/>
    
  </entry>
  
  <entry>
    <title>hexo本地博客系统以及github page建博客流程</title>
    <link href="http://yoursite.com/2016/05/04/hexo%E6%9C%AC%E5%9C%B0%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E4%BB%A5%E5%8F%8Agithub-page%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2016/05/04/hexo本地博客系统以及github-page建博客流程/</id>
    <published>2016-05-04T04:02:15.000Z</published>
    <updated>2016-05-04T04:26:24.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;a href=&quot;#大概记录下搭建这个博客的流程&quot; class=&quot;headerlink&quot; title=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;/a&gt;大概记录下搭建这个博客的流程&lt;/h2&gt;&lt;h3 id=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;a href=&quot;#这里只提大体流程，详细步骤可以参考下面的参考文章&quot; class=&quot;headerlink&quot; title=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;/a&gt;这里只提大体流程，详细步骤可以参考下面的参考文章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在github上申请新建一个repo，注意命名规范，这个会涉及到以后访问博客的url。这个repo就是以后博客的文章存放的地方&lt;/li&gt;
&lt;li&gt;搭建本地hexo博客系统。因为正常的流程都是从本地写好文章，部署到上面的repo就可以的。hexo系统可以方便地在本地写，支持命令行，还可以预览。文章本地写好之后就可以通过hexo直接部署到repo。&lt;/li&gt;
&lt;li&gt;配置hexo的部署需要在guthub网站上面配置ssh，然后在hexo里面的_config.yml填上你的仓库地址，第一次命令行部署需要填写github用户名和密码。&lt;/li&gt;
&lt;li&gt;可以自己更换一个博客的主题，需要配置一下config.yml，具体见下面的参考文章&lt;/li&gt;
&lt;li&gt;图片较多的话建议使用图床，我看其他教程里面七牛的多，试了下感觉还蛮好~~&lt;/li&gt;
&lt;/ol&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;hr&gt;
&lt;h3 id=&quot;写博客流程&quot;&gt;&lt;a href=&quot;#写博客流程&quot; class=&quot;headerlink&quot; title=&quot;写博客流程&quot;&gt;&lt;/a&gt;写博客流程&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;命令行进入博客的目录&lt;/li&gt;
&lt;li&gt;hexo new ‘文章标题’ ， 这时会在source/_post里面生成对应的文件夹和.md ，文件夹是用来存放此文章里面的资源的，例如图片&lt;/li&gt;
&lt;li&gt;编辑md文件，这个就是以后要发布的文章的内容，注意是按照Markdown语法来写的html，可以使用markdown编辑器，注意标记和内容之间的空格 和行之间空行&lt;/li&gt;
&lt;li&gt;hexo g （generate）， 将上面编辑的md生成html&lt;/li&gt;
&lt;li&gt;hexo s  （server），启动本地服务器预览文章， localhost：4000&lt;/li&gt;
&lt;li&gt;hexo d （deploy）预览无疑之后发布 ， 然后在 XXX.github.io里面就能看到写好的文章啦~&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;headerlink&quot; title=&quot;参考文章&quot;&gt;&lt;/a&gt;参考文章&lt;/h3&gt;&lt;p&gt;[1]. &lt;a href=&quot;http://www.jianshu.com/p/ecd51e8ef2fa&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/ecd51e8ef2fa&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[2]. &lt;a href=&quot;http://www.jianshu.com/p/05289a4bc8b2&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://www.jianshu.com/p/05289a4bc8b2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[3]. ..&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;a href=&quot;#大概记录下搭建这个博客的流程&quot; class=&quot;headerlink&quot; title=&quot;大概记录下搭建这个博客的流程&quot;&gt;&lt;/a&gt;大概记录下搭建这个博客的流程&lt;/h2&gt;&lt;h3 id=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;a href=&quot;#这里只提大体流程，详细步骤可以参考下面的参考文章&quot; class=&quot;headerlink&quot; title=&quot;这里只提大体流程，详细步骤可以参考下面的参考文章&quot;&gt;&lt;/a&gt;这里只提大体流程，详细步骤可以参考下面的参考文章&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;在github上申请新建一个repo，注意命名规范，这个会涉及到以后访问博客的url。这个repo就是以后博客的文章存放的地方&lt;/li&gt;
&lt;li&gt;搭建本地hexo博客系统。因为正常的流程都是从本地写好文章，部署到上面的repo就可以的。hexo系统可以方便地在本地写，支持命令行，还可以预览。文章本地写好之后就可以通过hexo直接部署到repo。&lt;/li&gt;
&lt;li&gt;配置hexo的部署需要在guthub网站上面配置ssh，然后在hexo里面的_config.yml填上你的仓库地址，第一次命令行部署需要填写github用户名和密码。&lt;/li&gt;
&lt;li&gt;可以自己更换一个博客的主题，需要配置一下config.yml，具体见下面的参考文章&lt;/li&gt;
&lt;li&gt;图片较多的话建议使用图床，我看其他教程里面七牛的多，试了下感觉还蛮好~~&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>读研之经历</title>
    <link href="http://yoursite.com/2016/05/04/%E8%AF%BB%E7%A0%94%E4%B9%8B%E7%BB%8F%E5%8E%86/"/>
    <id>http://yoursite.com/2016/05/04/读研之经历/</id>
    <published>2016-05-04T03:30:23.000Z</published>
    <updated>2016-05-04T03:47:41.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;a href=&quot;#熬到了研一下，忍不住想说下我的感受&quot; class=&quot;headerlink&quot; title=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;/a&gt;熬到了研一下，忍不住想说下我的感受&lt;/h2&gt;&lt;p&gt;在这里读硕的切身感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做什么东西都是自己做，遇到问题自己解决，问别人？ 抱歉，他们不做这个这个东西，只有你一个人在做。。&lt;/li&gt;
&lt;li&gt;不要奢望有个牛人带你，因为实在没有。。&lt;/li&gt;
&lt;li&gt;做paper的时候，从选paper到读只有你一个人在做。。老师不会帮你挑paper，读完也没有人交流，这就完事儿，这叫做研究？excuse me？真心为自己的未来担忧&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;一直觉得，为别人干活的动力有两个：一是收获很多技术上的成长，得到牛人的指导。二是没有什么收获，但是可以得到很多钱。。 所以，抱歉我还是默默去刷leetcode了&lt;/li&gt;
&lt;/ol&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;a href=&quot;#熬到了研一下，忍不住想说下我的感受&quot; class=&quot;headerlink&quot; title=&quot;熬到了研一下，忍不住想说下我的感受&quot;&gt;&lt;/a&gt;熬到了研一下，忍不住想说下我的感受&lt;/h2&gt;&lt;p&gt;在这里读硕的切身感受：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;做什么东西都是自己做，遇到问题自己解决，问别人？ 抱歉，他们不做这个这个东西，只有你一个人在做。。&lt;/li&gt;
&lt;li&gt;不要奢望有个牛人带你，因为实在没有。。&lt;/li&gt;
&lt;li&gt;做paper的时候，从选paper到读只有你一个人在做。。老师不会帮你挑paper，读完也没有人交流，这就完事儿，这叫做研究？excuse me？真心为自己的未来担忧
    
    </summary>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Done!</title>
    <link href="http://yoursite.com/2016/04/26/Done/"/>
    <id>http://yoursite.com/2016/04/26/Done/</id>
    <published>2016-04-26T08:10:01.000Z</published>
    <updated>2016-04-26T08:48:28.000Z</updated>
    
    <content type="html">&lt;h2 id=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;a href=&quot;#“费了半天劲终于把这个东东弄好了，那么问题来了”&quot; class=&quot;headerlink&quot; title=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;/a&gt;“费了半天劲终于把这个东东弄好了，那么问题来了”&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;OMG.jpg&quot; alt=&quot;已哭瞎&quot;&gt;&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;ol&gt;
&lt;li&gt;老板交给我的活儿还没有动。。&lt;/li&gt;
&lt;li&gt;明天要给老板交周报。。&lt;/li&gt;
&lt;li&gt;好了，我去干活啦（咻~~）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;来测试下代码&quot;&gt;&lt;a href=&quot;#来测试下代码&quot; class=&quot;headerlink&quot; title=&quot;来测试下代码&quot;&gt;&lt;/a&gt;来测试下代码&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;git clone&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&quot;来测试下图片&quot;&gt;&lt;a href=&quot;#来测试下图片&quot; class=&quot;headerlink&quot; title=&quot;来测试下图片**&quot;&gt;&lt;/a&gt;来测试下图片**&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;tuo.jpg&quot; alt=&quot;哎呀，图片挂啦&quot;&gt;&lt;/p&gt;
</content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;a href=&quot;#“费了半天劲终于把这个东东弄好了，那么问题来了”&quot; class=&quot;headerlink&quot; title=&quot;“费了半天劲终于把这个东东弄好了，那么问题来了”&quot;&gt;&lt;/a&gt;“费了半天劲终于把这个东东弄好了，那么问题来了”&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;OMG.jpg&quot; alt=&quot;已哭瞎&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="test" scheme="http://yoursite.com/tags/test/"/>
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
